/**
 * @file ts.h
 * @author Milinda Fernando
 * @brief generic time integrator class for Dendro. 
 * @version 0.1
 * @date 2019-10-18
 * 
 * School of Computing, University of Utah
 * @copyright Copyright (c) 2019
 * 
 */

#pragma once
#include "dendro.h"
#include "mesh.h"


namespace ts
{
    /**time stepper type
     * UTS uniform time stepper. 
     * UTS_ADAP: uniform over the grid but time step size changes over time. 
     * NUTS: spatially adaptive time stepping. 
     * NUTS_ADAP: NUTS where the smallest time step varies in time. 
     * 
    */
    enum TimeStepperType {UTS=0 , UTS_ADAP ,NUTS, NUTS_ADAP};

    /**
     * @brief default available RK methods. 
     */
    enum RK {RK3=0, RK4, RK5};

    /**
     * @brief ETS Flags (currently not used)
     */
    enum ETSFlags {FROM_T0 =0 , CHECKPT, CURR_STEP, CURR_TIME };
    
    /**
     * @brief ETS variable types
     */
    enum ETSVType {EVOLVE, CONSTRAINT, PRIMITIVE};
    /**
     * @brief General explicit time stepper class for Dendro-5.0
     * @tparam T 
     */
    template<typename T>
    class ETS
    {
        private: 

            /**@brief: list of evolution variables at time t=tk. */
            std::vector<T*> m_uiEvol_k;

            /**@brief: list of evolution variables at time t=tk+1. */
            std::vector<T*> m_uiEvol_kp1;
            
            /**@brief: list of conserved variables. or observed variables.computes the conserved vars after the evolution */
            std::vector<T*> m_uiConsVar;

            /**@brief: Primitive variables (variables computed from the evolution variables. )*/
            std::vector<T*> m_uiPrimVar;

            /**@brief : underlying mesh data structure generated by Dendro*/
            const ot::Mesh* m_uiMesh;

            /**@brief: Time stepper type*/
            TimeStepperType m_uiType;

            /**@brief: CFL factor*/
            DendroScalar m_uiCFL;

            /**@brief: time integrator coefficients for solution u*/
            DendroScalar* m_uiAij;

            /**@brief: time integrator coefficients for time */
            DendroScalar* m_uiBi;

            /**@brief: time integrator weights*/
            DendroScalar* m_uiCi;

            /**@brief: time integrator stages*/
            T** m_uiStages;

            /**@brief: number of stages*/
            unsigned int m_uiNumStages;

            /**@brief: begin time of the evolution*/
            DendroScalar m_uiTBegin;

            /**@brief: end time of the evolution*/
            DendroScalar m_uiTEnd;

            DendroScalar m_uiTCurr;

            DendroIntL m_uiCurrStep;

            /**@brief: evolve variable unzip in */
            std::vector<T*> m_uiEvolUnzipIn;

            /**@brief: evolve variable unzip out */
            std::vector<T*> m_uiEvolUnzipOut;

            /**@brief: evolve variable constraint in */
            std::vector<T*> m_uiConsUnzipIn;
            
            /**@brief: evolve variable constraint out */
            std::vector<T*> m_uiConsUnzipOut;

            /**@brief: evolve variable primitive unzip in */
            std::vector<T*> m_uiPrimUnzipIn;

            /**@brief: evolve variable primitive unzip out*/
            std::vector<T*> m_uiPrimUnzipOut;

            /**@brief: Total memory allocated for time stepper in B */
            DendroIntL m_uiMemAlloc;

            /**@brief: Total memory deallocated for time stepper B*/
            DendroIntL m_uiMemDeAlloc;

            /** @brief : initial condition for the ETS    */
            std::function<int(T**, T)> m_uiInitCon;

            /** @brief : function called before each stage*/
            std::function<int(T**, T**, T)> m_uiPreStage;

            /** @brief : function called after each stage*/
            std::function<int(T**, T**, T)> m_uiPostStage;
            
            /** @brief : function call before each time step*/
            std::function<int(T**, T**, T)> m_uiPreStep;

            /** @brief : function call after each time step*/
            std::function<int(T**, T**, T)> m_uiPostStep;

            /** @brief : F(u,t)*/
            std::function<int(T**, T**, T)> m_uiFrhs;

            /** @brief : compute constraints*/
            std::function<int(T**,T**, T)> m_uiCompContraints;

            /** @brief: min point of the compute domain. */
            Point m_uiMinPt;
            
            /**@brief: max point of the compute domain */
            Point m_uiMaxPt;


        private:

            /**
             * @brief unzip the variables. 
             * @param type variable type
             */
            void unzip(ETSVType type);

            /**
             * @brief zip the variables. 
             * @param type variable type
             */
            void zip(ETSVType type);

        public: 
            /**
             * @brief Construct a new ETS object
             * @param pMesh : underlying mesh data structure. 
             */
            ETS(const ot::Mesh* pMesh);
            
            /**
             * @brief Destroy the ETS object
             */
            ~ETS();

            /**
             * @brief Set the ets coefficients
             * $ k_i = f(u^{n} + \sum_{j=1}^{i-1} a_{i,j}*dt , t^{n} + b_i*th)$
             * $u^{n+1} = u^{n} + \sum_{m=1}^{num\_stages} k_m $
             * @param aij : time integrator coefficients for the f_rhs first term
             * @param bi : time integrator coefficients for the f_rhs second term
             * @param ci : time integrator weights
             * @param num_stages : number of stages 
             * @return int : is success return zero. 
             */
            int set_ets_coefficients(DendroScalar * aij , DendroScalar * bi ,DendroScalar * ci,unsigned int num_stages);
            
            /**@brief initialize the ETS solver*/
            void init(DendroScalar t);

            /**@brief returns the current time step*/
            inline DendroIntL currStep() {return m_uiCurrStep;};

            /**@brief returns the current time*/
            inline DendroIntL currTime() {return m_uiTCurr;};

            /**@brief: advance to next time step*/
            void evolve();
            
            /**@brief Add variables to the time stepper*/
            void add_var(T* v, ETSVType type);
            
            /**@brief Add variables to the time stepper*/
            void add_vars(T** v, unsigned int sz, ETSVType type);

            /**@brief set the intial data routine*/
            inline void set_initdata_func(std::function<T**, T> f) {m_uiInitCon =f;}

            /**@brief set the pre stage function routine*/
            inline void set_pre_stage_func(std::function<T**, T** ,T> f) {m_uiPreStage =f;}

            /**@brief set the post stage function routine*/
            inline void set_post_stage_func(std::function<T**, T** ,T> f) {m_uiPostStage =f;}

            /**@brief set the pre timestep function routine*/
            inline void set_pre_timestep_func(std::function<T**, T** ,T> f) {m_uiPreStep =f;}

            /**@brief set the post timestep function routine*/
            inline void set_post_timestep_func(std::function<T**, T** ,T> f) {m_uiPostStep =f;}

            /**@brief: set the rhs routine*/
            inline void set_rhs(std::function<T**, T** ,T> f) { m_uiFrhs = f; }

            /**@brief set the constraint function routine*/
            inline void set_constraint_fuc(std::function<T**,T**,T> f ) {m_uiCompContraints =f};
            
            /**@brief: returns the variables*/
            const std::vector<T*> getVars(ETSVType vtype);


    };


    template<typename T>
    ETS<T>::ETS(const ot::Mesh* pMesh)
    {
        m_uiMesh = pMesh;
        m_uiAij = NULL;
        m_uiBi = NULL;
        m_uiCi = NULL;

        m_uiNumStages  = 0;

        m_uiTBegin = 0;
        m_uiCurrStep=0;
        m_uiTCurr = 0;
        m_uiTEnd = 0;
    }

    template<typename T>
    int ETS<T>::set_ets_coefficients(DendroScalar * aij , DendroScalar * bi ,DendroScalar * ci,unsigned int num_stages)
    {
        m_uiAij = aij;
        m_uiBi  = bi;
        m_uiCi  = ci;

        m_uiNumStages = num_stages;
        return 0;

    }


    template<typename T>
    void ETS<T>::add_var(T* v, ETSVType type)
    {
        if(type == ETSVType::EVOLVE)
            m_uiEvol_k.push_back(v);
        else if(type == ETSVType::CONSTRAINT)
            m_uiConsVar.push_back(v);
    }
    

    template<typename T>
    void ETS<T>::add_vars(T** v, unsigned int sz, ETSVType type)
    {
        if(type == ETSVType::EVOLVE)
        {
            for(unsigned int i=0;i<sz;i++)
                m_uiEvol_k.push_back(v[i]);

        }
        else if (type ==ETSVType::CONSTRAINT)
        {
            for(unsigned int i=0;i<sz;i++)
                m_uiConsVar.push_back(v[i]);
        }

    }



    template<typename T>
    void ETS<T>::evolve()
    {

        if(m_uiMesh->isActive())
        {
            double current_t=m_uiCurrentTime;
            double current_t_adv=current_t;

            unzip(ts::ETSVType::EVOLVE);
            int rank =m_uiMesh->getMPIRank();

            const unsigned int nodeLocalBegin=m_uiMesh->getNodeLocalBegin();
            const unsigned int nodeLocalEnd=m_uiMesh->getNodeLocalEnd();

            const std::vector<ot::Block> blkList=m_uiMesh->getLocalBlockList();
            unsigned int offset;
            double ptmin[3], ptmax[3];
            unsigned int sz[3];
            unsigned int bflag;
            double dx,dy,dz;


            for(unsigned int stage=0; stage< (m_uiNumStages-1) ; stage++)
            {


                for(unsigned int blk=0; blk<blkList.size(); blk++)
                {
                    offset=blkList[blk].getOffset();
                    sz[0]=blkList[blk].getAllocationSzX();
                    sz[1]=blkList[blk].getAllocationSzY();
                    sz[2]=blkList[blk].getAllocationSzZ();

                    bflag=blkList[blk].getBlkNodeFlag();

                    dx=blkList[blk].computeDx(m_uiMinPt,m_uiMaxPt);
                    dy=blkList[blk].computeDy(m_uiMinPt,m_uiMaxPt);
                    dz=blkList[blk].computeDz(m_uiMinPt,m_uiMaxPt);

                    ptmin[0]=GRIDX_TO_X(blkList[blk].getBlockNode().minX())-3*dx;
                    ptmin[1]=GRIDY_TO_Y(blkList[blk].getBlockNode().minY())-3*dy;
                    ptmin[2]=GRIDZ_TO_Z(blkList[blk].getBlockNode().minZ())-3*dz;

                    ptmax[0]=GRIDX_TO_X(blkList[blk].getBlockNode().maxX())+3*dx;
                    ptmax[1]=GRIDY_TO_Y(blkList[blk].getBlockNode().maxY())+3*dy;
                    ptmax[2]=GRIDZ_TO_Z(blkList[blk].getBlockNode().maxZ())+3*dz;


                    // rhs

                }


                zipVars(m_uiUnzipVarRHS,m_uiStage[stage]);

                for(unsigned int node=nodeLocalBegin; node<nodeLocalEnd; node++)
                {
                    for(unsigned int index=0; index<bssn::BSSN_NUM_VARS; index++)
                    {
                        m_uiVarIm[index][node]=m_uiPrevVar[index][node];
                        //if(!rank && index==0 && node==0) std::cout<<"rk stage: "<<stage<<" im coef: "<<stage<<" value: "<<RK4_U[stage+1]<<std::endl;
                        m_uiVarIm[index][node] += (RK4_U[stage + 1] * m_uiT_h * m_uiStage[stage][index][node]);

                    }
                    enforce_bssn_constraints(m_uiVarIm, node);
                }


                current_t_adv=current_t+RK4_T[stage+1]*m_uiT_h;
                
                // unzip


            }

            current_t_adv=current_t+RK4_T[(m_uiNumStages-1)]*m_uiT_h;



            for(unsigned int blk=0; blk<blkList.size(); blk++)
            {

                offset=blkList[blk].getOffset();
                sz[0]=blkList[blk].getAllocationSzX();
                sz[1]=blkList[blk].getAllocationSzY();
                sz[2]=blkList[blk].getAllocationSzZ();

                bflag=blkList[blk].getBlkNodeFlag();

                dx=blkList[blk].computeDx(m_uiMinPt,m_uiMaxPt);
                dy=blkList[blk].computeDy(m_uiMinPt,m_uiMaxPt);
                dz=blkList[blk].computeDz(m_uiMinPt,m_uiMaxPt);

                ptmin[0]=GRIDX_TO_X(blkList[blk].getBlockNode().minX())-3*dx;
                ptmin[1]=GRIDY_TO_Y(blkList[blk].getBlockNode().minY())-3*dy;
                ptmin[2]=GRIDZ_TO_Z(blkList[blk].getBlockNode().minZ())-3*dz;

                ptmax[0]=GRIDX_TO_X(blkList[blk].getBlockNode().maxX())+3*dx;
                ptmax[1]=GRIDY_TO_Y(blkList[blk].getBlockNode().maxY())+3*dy;
                ptmax[2]=GRIDZ_TO_Z(blkList[blk].getBlockNode().maxZ())+3*dz;


                // rhs


            }

            // zip
            zipVars(m_uiUnzipVarRHS,m_uiStage[(bssn::BSSN_RK4_STAGES-1)]);

            for(unsigned int node=nodeLocalBegin; node<nodeLocalEnd; node++)
            {

                for(unsigned int index=0; index<bssn::BSSN_NUM_VARS; index++)
                {
                    m_uiVar[index][node]=m_uiPrevVar[index][node];
                    for(unsigned int s=0; s<(bssn::BSSN_RK4_STAGES); s++)
                    {
                        m_uiVar[index][node]+=(RK4_C[s]*m_uiT_h*m_uiStage[s][index][node]);
                    }


                }
                enforce_bssn_constraints(m_uiVar, node);

            }

        }

        
    }




}// end of namespace ts
