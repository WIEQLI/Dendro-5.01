<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Dendro-5.01: ot::Mesh Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Dendro-5.01
   &#160;<span id="projectnumber">Dendro-5.01</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespaceot.html">ot</a></li><li class="navelem"><a class="el" href="classot_1_1Mesh.html">Mesh</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="classot_1_1Mesh-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">ot::Mesh Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;<a class="el" href="mesh_8h_source.html">mesh.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:ac84f51f52c587c2e4ad561c825cac86d"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classot_1_1Mesh.html#ac84f51f52c587c2e4ad561c825cac86d">Mesh</a> (std::vector&lt; <a class="el" href="classot_1_1TreeNode.html">ot::TreeNode</a> &gt; &amp;in, unsigned int k_s, unsigned int pOrder, unsigned int activeNpes, MPI_Comm comm, bool pBlockSetup=true, <a class="el" href="namespaceot.html#a56125ff5472322284829fbf97534d6f0">SM_TYPE</a> smType=SM_TYPE::FDM, unsigned int grainSz=DENDRO_DEFAULT_GRAIN_SZ, double ld_tol=DENDRO_DEFAULT_LB_TOL, unsigned int sf_k=DENDRO_DEFAULT_SF_K)</td></tr>
<tr class="memdesc:ac84f51f52c587c2e4ad561c825cac86d"><td class="mdescLeft">&#160;</td><td class="mdescRight">parallel mesh constructor  <a href="#ac84f51f52c587c2e4ad561c825cac86d">More...</a><br /></td></tr>
<tr class="separator:ac84f51f52c587c2e4ad561c825cac86d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af6b6ae09c85674e2a330a70e2ef67200"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classot_1_1Mesh.html#af6b6ae09c85674e2a330a70e2ef67200">Mesh</a> (std::vector&lt; <a class="el" href="classot_1_1TreeNode.html">ot::TreeNode</a> &gt; &amp;in, unsigned int k_s, unsigned int pOrder, MPI_Comm comm, bool pBlockSetup=true, <a class="el" href="namespaceot.html#a56125ff5472322284829fbf97534d6f0">SM_TYPE</a> smType=SM_TYPE::FDM, unsigned int grainSz=DENDRO_DEFAULT_GRAIN_SZ, double ld_tol=DENDRO_DEFAULT_LB_TOL, unsigned int sf_k=DENDRO_DEFAULT_SF_K)</td></tr>
<tr class="memdesc:af6b6ae09c85674e2a330a70e2ef67200"><td class="mdescLeft">&#160;</td><td class="mdescRight">parallel mesh constructor  <a href="#af6b6ae09c85674e2a330a70e2ef67200">More...</a><br /></td></tr>
<tr class="separator:af6b6ae09c85674e2a330a70e2ef67200"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a33cdc29f1f0f0fc070cf281d24ac6546"><td class="memItemLeft" align="right" valign="top"><a id="a33cdc29f1f0f0fc070cf281d24ac6546"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classot_1_1Mesh.html#a33cdc29f1f0f0fc070cf281d24ac6546">~Mesh</a> ()</td></tr>
<tr class="memdesc:a33cdc29f1f0f0fc070cf281d24ac6546"><td class="mdescLeft">&#160;</td><td class="mdescRight">destructor for mesh (releases the allocated variables in the class. ) <br /></td></tr>
<tr class="separator:a33cdc29f1f0f0fc070cf281d24ac6546"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a64cebc3d69e16590ab65c0eeaf99fc0d"><td class="memItemLeft" align="right" valign="top"><a id="a64cebc3d69e16590ab65c0eeaf99fc0d"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classot_1_1Mesh.html#a64cebc3d69e16590ab65c0eeaf99fc0d">performBlocksSetup</a> ()</td></tr>
<tr class="memdesc:a64cebc3d69e16590ab65c0eeaf99fc0d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Perform the blocks initialization so that we can apply the stencil for the grid as a sequnce of finite number of regular grids. note that this should be called after performing all E2N and E2N mapping. <br /></td></tr>
<tr class="separator:a64cebc3d69e16590ab65c0eeaf99fc0d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1ad96931fd314e48f5e0a677102fc717"><td class="memItemLeft" align="right" valign="top"><a id="a1ad96931fd314e48f5e0a677102fc717"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classot_1_1Mesh.html#a1ad96931fd314e48f5e0a677102fc717">buildF2EMap</a> ()</td></tr>
<tr class="memdesc:a1ad96931fd314e48f5e0a677102fc717"><td class="mdescLeft">&#160;</td><td class="mdescRight">computes the face to element map. needs to be called after e2e and e2n maps has built. <br /></td></tr>
<tr class="separator:a1ad96931fd314e48f5e0a677102fc717"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af16eb22a2b9d4702649ff99794060d24"><td class="memItemLeft" align="right" valign="top"><a id="af16eb22a2b9d4702649ff99794060d24"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>flagBlocks</b> ()</td></tr>
<tr class="separator:af16eb22a2b9d4702649ff99794060d24"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad8439096888bf6d196491cb5e0ecc640"><td class="memItemLeft" align="right" valign="top"><a id="ad8439096888bf6d196491cb5e0ecc640"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classot_1_1Mesh.html#ad8439096888bf6d196491cb5e0ecc640">isBlockSetep</a> ()</td></tr>
<tr class="memdesc:ad8439096888bf6d196491cb5e0ecc640"><td class="mdescLeft">&#160;</td><td class="mdescRight">: returns if the block setup has performed or not <br /></td></tr>
<tr class="separator:ad8439096888bf6d196491cb5e0ecc640"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1c4724d55d3cdba3584aa289beb3ad76"><td class="memItemLeft" align="right" valign="top"><a id="a1c4724d55d3cdba3584aa289beb3ad76"></a>
<a class="el" href="namespaceot.html#a56125ff5472322284829fbf97534d6f0">SM_TYPE</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classot_1_1Mesh.html#a1c4724d55d3cdba3584aa289beb3ad76">getScatterMapType</a> ()</td></tr>
<tr class="memdesc:a1c4724d55d3cdba3584aa289beb3ad76"><td class="mdescLeft">&#160;</td><td class="mdescRight">: returns if the scatter map typed set <br /></td></tr>
<tr class="separator:a1c4724d55d3cdba3584aa289beb3ad76"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0a92b2be52e5928545ff2ab9e89432d4"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classot_1_1Mesh.html#a0a92b2be52e5928545ff2ab9e89432d4">getNumLocalMeshElements</a> () const</td></tr>
<tr class="separator:a0a92b2be52e5928545ff2ab9e89432d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a966ccc67ddc5e0b710db1928af7808ea"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classot_1_1Mesh.html#a966ccc67ddc5e0b710db1928af7808ea">getNumPreGhostElements</a> () const</td></tr>
<tr class="separator:a966ccc67ddc5e0b710db1928af7808ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5850cd19b40a586c8366ca8302db112f"><td class="memItemLeft" align="right" valign="top"><a id="a5850cd19b40a586c8366ca8302db112f"></a>
unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classot_1_1Mesh.html#a5850cd19b40a586c8366ca8302db112f">getNumPostGhostElements</a> () const</td></tr>
<tr class="memdesc:a5850cd19b40a586c8366ca8302db112f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of post-ghost elements. <br /></td></tr>
<tr class="separator:a5850cd19b40a586c8366ca8302db112f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a31a8fe4289586122560fda093a726b6c"><td class="memItemLeft" align="right" valign="top"><a id="a31a8fe4289586122560fda093a726b6c"></a>
unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classot_1_1Mesh.html#a31a8fe4289586122560fda093a726b6c">getNumLocalMeshNodes</a> () const</td></tr>
<tr class="memdesc:a31a8fe4289586122560fda093a726b6c"><td class="mdescLeft">&#160;</td><td class="mdescRight">return the number of nodes local to the mesh <br /></td></tr>
<tr class="separator:a31a8fe4289586122560fda093a726b6c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c2b4fc6ad15db6440a2fc6f12670821"><td class="memItemLeft" align="right" valign="top"><a id="a3c2b4fc6ad15db6440a2fc6f12670821"></a>
unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classot_1_1Mesh.html#a3c2b4fc6ad15db6440a2fc6f12670821">getNumPreMeshNodes</a> () const</td></tr>
<tr class="memdesc:a3c2b4fc6ad15db6440a2fc6f12670821"><td class="mdescLeft">&#160;</td><td class="mdescRight">return the number of pre ghost mesh nodes <br /></td></tr>
<tr class="separator:a3c2b4fc6ad15db6440a2fc6f12670821"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aac2652e32b852bbf37eabfb619ed5578"><td class="memItemLeft" align="right" valign="top"><a id="aac2652e32b852bbf37eabfb619ed5578"></a>
unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classot_1_1Mesh.html#aac2652e32b852bbf37eabfb619ed5578">getNumPostMeshNodes</a> () const</td></tr>
<tr class="memdesc:aac2652e32b852bbf37eabfb619ed5578"><td class="mdescLeft">&#160;</td><td class="mdescRight">return the number of post ghost mesh nodes <br /></td></tr>
<tr class="separator:aac2652e32b852bbf37eabfb619ed5578"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3966a069c65b929f83cd9290433ffb77"><td class="memItemLeft" align="right" valign="top"><a id="a3966a069c65b929f83cd9290433ffb77"></a>
unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classot_1_1Mesh.html#a3966a069c65b929f83cd9290433ffb77">getElementPreGhostBegin</a> () const</td></tr>
<tr class="memdesc:a3966a069c65b929f83cd9290433ffb77"><td class="mdescLeft">&#160;</td><td class="mdescRight">return the begin location of element pre ghost <br /></td></tr>
<tr class="separator:a3966a069c65b929f83cd9290433ffb77"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0ded784867c170797e4024704db6626d"><td class="memItemLeft" align="right" valign="top"><a id="a0ded784867c170797e4024704db6626d"></a>
unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classot_1_1Mesh.html#a0ded784867c170797e4024704db6626d">getElementPreGhostEnd</a> () const</td></tr>
<tr class="memdesc:a0ded784867c170797e4024704db6626d"><td class="mdescLeft">&#160;</td><td class="mdescRight">return the end location of element pre ghost <br /></td></tr>
<tr class="separator:a0ded784867c170797e4024704db6626d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a867642eb76ab3d3b1c0f1c9b0ae5f9c5"><td class="memItemLeft" align="right" valign="top"><a id="a867642eb76ab3d3b1c0f1c9b0ae5f9c5"></a>
unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classot_1_1Mesh.html#a867642eb76ab3d3b1c0f1c9b0ae5f9c5">getElementLocalBegin</a> () const</td></tr>
<tr class="memdesc:a867642eb76ab3d3b1c0f1c9b0ae5f9c5"><td class="mdescLeft">&#160;</td><td class="mdescRight">return the begin location of element local <br /></td></tr>
<tr class="separator:a867642eb76ab3d3b1c0f1c9b0ae5f9c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9bee46340ad5ef1b950a05e549886a0e"><td class="memItemLeft" align="right" valign="top"><a id="a9bee46340ad5ef1b950a05e549886a0e"></a>
unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classot_1_1Mesh.html#a9bee46340ad5ef1b950a05e549886a0e">getElementLocalEnd</a> () const</td></tr>
<tr class="memdesc:a9bee46340ad5ef1b950a05e549886a0e"><td class="mdescLeft">&#160;</td><td class="mdescRight">return the end location of element local <br /></td></tr>
<tr class="separator:a9bee46340ad5ef1b950a05e549886a0e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abad68b0c7549fb0f4bf40d12ebf518b6"><td class="memItemLeft" align="right" valign="top"><a id="abad68b0c7549fb0f4bf40d12ebf518b6"></a>
unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classot_1_1Mesh.html#abad68b0c7549fb0f4bf40d12ebf518b6">getElementPostGhostBegin</a> () const</td></tr>
<tr class="memdesc:abad68b0c7549fb0f4bf40d12ebf518b6"><td class="mdescLeft">&#160;</td><td class="mdescRight">return the begin location of element post ghost <br /></td></tr>
<tr class="separator:abad68b0c7549fb0f4bf40d12ebf518b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aac6fdab722a0031d99df2d28f223e2b9"><td class="memItemLeft" align="right" valign="top"><a id="aac6fdab722a0031d99df2d28f223e2b9"></a>
unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classot_1_1Mesh.html#aac6fdab722a0031d99df2d28f223e2b9">getElementPostGhostEnd</a> () const</td></tr>
<tr class="memdesc:aac6fdab722a0031d99df2d28f223e2b9"><td class="mdescLeft">&#160;</td><td class="mdescRight">return the end location of element post ghost <br /></td></tr>
<tr class="separator:aac6fdab722a0031d99df2d28f223e2b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3abc6edb4318d58d239231637ec181b3"><td class="memItemLeft" align="right" valign="top"><a id="a3abc6edb4318d58d239231637ec181b3"></a>
unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classot_1_1Mesh.html#a3abc6edb4318d58d239231637ec181b3">getNodePreGhostBegin</a> () const</td></tr>
<tr class="memdesc:a3abc6edb4318d58d239231637ec181b3"><td class="mdescLeft">&#160;</td><td class="mdescRight">return the begin location of pre ghost nodes <br /></td></tr>
<tr class="separator:a3abc6edb4318d58d239231637ec181b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae9c2ec041ef39c2a6217aba8c9f3908f"><td class="memItemLeft" align="right" valign="top"><a id="ae9c2ec041ef39c2a6217aba8c9f3908f"></a>
unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classot_1_1Mesh.html#ae9c2ec041ef39c2a6217aba8c9f3908f">getNodePreGhostEnd</a> () const</td></tr>
<tr class="memdesc:ae9c2ec041ef39c2a6217aba8c9f3908f"><td class="mdescLeft">&#160;</td><td class="mdescRight">return the end location of pre ghost nodes <br /></td></tr>
<tr class="separator:ae9c2ec041ef39c2a6217aba8c9f3908f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afb21db6cf8acace27cde7710a9d7b63b"><td class="memItemLeft" align="right" valign="top"><a id="afb21db6cf8acace27cde7710a9d7b63b"></a>
unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classot_1_1Mesh.html#afb21db6cf8acace27cde7710a9d7b63b">getNodeLocalBegin</a> () const</td></tr>
<tr class="memdesc:afb21db6cf8acace27cde7710a9d7b63b"><td class="mdescLeft">&#160;</td><td class="mdescRight">return the location of local node begin <br /></td></tr>
<tr class="separator:afb21db6cf8acace27cde7710a9d7b63b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a26756a92156306654d48a668fbf43da5"><td class="memItemLeft" align="right" valign="top"><a id="a26756a92156306654d48a668fbf43da5"></a>
unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classot_1_1Mesh.html#a26756a92156306654d48a668fbf43da5">getNodeLocalEnd</a> () const</td></tr>
<tr class="memdesc:a26756a92156306654d48a668fbf43da5"><td class="mdescLeft">&#160;</td><td class="mdescRight">return the location of local node end <br /></td></tr>
<tr class="separator:a26756a92156306654d48a668fbf43da5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:add1906fd47e5277eef2786038a4c80c9"><td class="memItemLeft" align="right" valign="top"><a id="add1906fd47e5277eef2786038a4c80c9"></a>
unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classot_1_1Mesh.html#add1906fd47e5277eef2786038a4c80c9">getNodePostGhostBegin</a> () const</td></tr>
<tr class="memdesc:add1906fd47e5277eef2786038a4c80c9"><td class="mdescLeft">&#160;</td><td class="mdescRight">return the location of post node begin <br /></td></tr>
<tr class="separator:add1906fd47e5277eef2786038a4c80c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7ff69b9b21f2024299f8271e0b67ca16"><td class="memItemLeft" align="right" valign="top"><a id="a7ff69b9b21f2024299f8271e0b67ca16"></a>
unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classot_1_1Mesh.html#a7ff69b9b21f2024299f8271e0b67ca16">getNodePostGhostEnd</a> () const</td></tr>
<tr class="memdesc:a7ff69b9b21f2024299f8271e0b67ca16"><td class="mdescLeft">&#160;</td><td class="mdescRight">return the location of post node end <br /></td></tr>
<tr class="separator:a7ff69b9b21f2024299f8271e0b67ca16"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad776c594811ae199e5de137db2ef59ae"><td class="memItemLeft" align="right" valign="top"><a id="ad776c594811ae199e5de137db2ef59ae"></a>
unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classot_1_1Mesh.html#ad776c594811ae199e5de137db2ef59ae">getDegOfFreedom</a> () const</td></tr>
<tr class="memdesc:ad776c594811ae199e5de137db2ef59ae"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns the dof for a partition <br /></td></tr>
<tr class="separator:ad776c594811ae199e5de137db2ef59ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad665647d6484d96aaa34c771d69e8deb"><td class="memItemLeft" align="right" valign="top"><a id="ad665647d6484d96aaa34c771d69e8deb"></a>
unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classot_1_1Mesh.html#ad665647d6484d96aaa34c771d69e8deb">getDegOfFreedomUnZip</a> () const</td></tr>
<tr class="memdesc:ad665647d6484d96aaa34c771d69e8deb"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns the dof for a partition <br /></td></tr>
<tr class="separator:ad665647d6484d96aaa34c771d69e8deb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a119208ebafbd68f3124a43aa45ce2765"><td class="memItemLeft" align="right" valign="top"><a id="a119208ebafbd68f3124a43aa45ce2765"></a>
const std::vector&lt; <a class="el" href="classot_1_1TreeNode.html">ot::TreeNode</a> &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classot_1_1Mesh.html#a119208ebafbd68f3124a43aa45ce2765">getAllElements</a> () const</td></tr>
<tr class="memdesc:a119208ebafbd68f3124a43aa45ce2765"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns the pointer to All elements array. <br /></td></tr>
<tr class="separator:a119208ebafbd68f3124a43aa45ce2765"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad919878f82cff15c7a3ce0ae261807b1"><td class="memItemLeft" align="right" valign="top"><a id="ad919878f82cff15c7a3ce0ae261807b1"></a>
const std::vector&lt; unsigned int &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classot_1_1Mesh.html#ad919878f82cff15c7a3ce0ae261807b1">getLevel1GhostElementIndices</a> () const</td></tr>
<tr class="memdesc:ad919878f82cff15c7a3ce0ae261807b1"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns the Level 1 ghost element indices. <br /></td></tr>
<tr class="separator:ad919878f82cff15c7a3ce0ae261807b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a23892c9ac9e55d37a7d9d2dc5a39334e"><td class="memItemLeft" align="right" valign="top"><a id="a23892c9ac9e55d37a7d9d2dc5a39334e"></a>
const std::vector&lt; <a class="el" href="classot_1_1TreeNode.html">ot::TreeNode</a> &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classot_1_1Mesh.html#a23892c9ac9e55d37a7d9d2dc5a39334e">getSplitterElements</a> () const</td></tr>
<tr class="memdesc:a23892c9ac9e55d37a7d9d2dc5a39334e"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns the splitter elements of the mesh local elements. <br /></td></tr>
<tr class="separator:a23892c9ac9e55d37a7d9d2dc5a39334e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b2b41102b7e08355fb3aa174e62fe44"><td class="memItemLeft" align="right" valign="top"><a id="a2b2b41102b7e08355fb3aa174e62fe44"></a>
const std::vector&lt; <a class="el" href="classot_1_1TreeNode.html">ot::TreeNode</a> &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classot_1_1Mesh.html#a2b2b41102b7e08355fb3aa174e62fe44">getAllLocalNodes</a> () const</td></tr>
<tr class="memdesc:a2b2b41102b7e08355fb3aa174e62fe44"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns all local nodes(vertices) <br /></td></tr>
<tr class="separator:a2b2b41102b7e08355fb3aa174e62fe44"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1dbb4b441ba764d54c5c9a8ca256096f"><td class="memItemLeft" align="right" valign="top"><a id="a1dbb4b441ba764d54c5c9a8ca256096f"></a>
const std::vector&lt; unsigned int &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classot_1_1Mesh.html#a1dbb4b441ba764d54c5c9a8ca256096f">getE2EMapping</a> () const</td></tr>
<tr class="memdesc:a1dbb4b441ba764d54c5c9a8ca256096f"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns const e2e mapping instance. <br /></td></tr>
<tr class="separator:a1dbb4b441ba764d54c5c9a8ca256096f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac32100681264cb448922827e2ed8512e"><td class="memItemLeft" align="right" valign="top">const std::vector&lt; unsigned int &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classot_1_1Mesh.html#ac32100681264cb448922827e2ed8512e">getE2NMapping</a> () const</td></tr>
<tr class="separator:ac32100681264cb448922827e2ed8512e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a14110c28f7cb8ebbf282aed7c3b4041d"><td class="memItemLeft" align="right" valign="top"><a id="a14110c28f7cb8ebbf282aed7c3b4041d"></a>
const std::vector&lt; unsigned int &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classot_1_1Mesh.html#a14110c28f7cb8ebbf282aed7c3b4041d">getDG2CGMap</a> () const</td></tr>
<tr class="memdesc:a14110c28f7cb8ebbf282aed7c3b4041d"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns dg to cg map <br /></td></tr>
<tr class="separator:a14110c28f7cb8ebbf282aed7c3b4041d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a07a05febfb9165e822679aed1807c7de"><td class="memItemLeft" align="right" valign="top"><a id="a07a05febfb9165e822679aed1807c7de"></a>
const std::vector&lt; unsigned int &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classot_1_1Mesh.html#a07a05febfb9165e822679aed1807c7de">getCG2DGMap</a> () const</td></tr>
<tr class="memdesc:a07a05febfb9165e822679aed1807c7de"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns cg to dg map <br /></td></tr>
<tr class="separator:a07a05febfb9165e822679aed1807c7de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9fe0d15495d3a0763b8abd59b79b61a7"><td class="memItemLeft" align="right" valign="top">const std::vector&lt; unsigned int &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classot_1_1Mesh.html#a9fe0d15495d3a0763b8abd59b79b61a7">getE2NMapping_DG</a> () const</td></tr>
<tr class="separator:a9fe0d15495d3a0763b8abd59b79b61a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9281b0e36855b7fb50b29b29766db68f"><td class="memItemLeft" align="right" valign="top"><a id="a9281b0e36855b7fb50b29b29766db68f"></a>
const std::vector&lt; <a class="el" href="classot_1_1Block.html">ot::Block</a> &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classot_1_1Mesh.html#a9281b0e36855b7fb50b29b29766db68f">getLocalBlockList</a> () const</td></tr>
<tr class="memdesc:a9281b0e36855b7fb50b29b29766db68f"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns const list of local blocks (regular grids) for the consdering mesh. <br /></td></tr>
<tr class="separator:a9281b0e36855b7fb50b29b29766db68f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4220044958b04212fdf1d9fa5955f572"><td class="memItemLeft" align="right" valign="top"><a id="a4220044958b04212fdf1d9fa5955f572"></a>
unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classot_1_1Mesh.html#a4220044958b04212fdf1d9fa5955f572">getNumDirections</a> () const</td></tr>
<tr class="memdesc:a4220044958b04212fdf1d9fa5955f572"><td class="mdescLeft">&#160;</td><td class="mdescRight">return the number of directions in the E2E mapping. <br /></td></tr>
<tr class="separator:a4220044958b04212fdf1d9fa5955f572"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a19219a5422638c3e4ee0b818260db458"><td class="memItemLeft" align="right" valign="top"><a id="a19219a5422638c3e4ee0b818260db458"></a>
unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classot_1_1Mesh.html#a19219a5422638c3e4ee0b818260db458">getNumNodesPerElement</a> () const</td></tr>
<tr class="memdesc:a19219a5422638c3e4ee0b818260db458"><td class="mdescLeft">&#160;</td><td class="mdescRight">return the number of nodes per element. <br /></td></tr>
<tr class="separator:a19219a5422638c3e4ee0b818260db458"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a410a49f20ac8fdded58c17458ae3271b"><td class="memItemLeft" align="right" valign="top"><a id="a410a49f20ac8fdded58c17458ae3271b"></a>
unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classot_1_1Mesh.html#a410a49f20ac8fdded58c17458ae3271b">getElementOrder</a> () const</td></tr>
<tr class="memdesc:a410a49f20ac8fdded58c17458ae3271b"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns the order of an element <br /></td></tr>
<tr class="separator:a410a49f20ac8fdded58c17458ae3271b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7bb5a7bce18e83c1f769840938a7370f"><td class="memItemLeft" align="right" valign="top"><a id="a7bb5a7bce18e83c1f769840938a7370f"></a>
MPI_Comm&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classot_1_1Mesh.html#a7bb5a7bce18e83c1f769840938a7370f">getMPICommunicator</a> () const</td></tr>
<tr class="memdesc:a7bb5a7bce18e83c1f769840938a7370f"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns the communicator (acitve) <br /></td></tr>
<tr class="separator:a7bb5a7bce18e83c1f769840938a7370f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abeb4fdc60309297c22a0ef8db162a291"><td class="memItemLeft" align="right" valign="top"><a id="abeb4fdc60309297c22a0ef8db162a291"></a>
MPI_Comm&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classot_1_1Mesh.html#abeb4fdc60309297c22a0ef8db162a291">getMPIGlobalCommunicator</a> () const</td></tr>
<tr class="memdesc:abeb4fdc60309297c22a0ef8db162a291"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns the global communicator <br /></td></tr>
<tr class="separator:abeb4fdc60309297c22a0ef8db162a291"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a288b46f650a0e14f7a8a72c92d598644"><td class="memItemLeft" align="right" valign="top"><a id="a288b46f650a0e14f7a8a72c92d598644"></a>
unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classot_1_1Mesh.html#a288b46f650a0e14f7a8a72c92d598644">getMPIRankGlobal</a> () const</td></tr>
<tr class="memdesc:a288b46f650a0e14f7a8a72c92d598644"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns the rank w.r.t. global comm <br /></td></tr>
<tr class="separator:a288b46f650a0e14f7a8a72c92d598644"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac1f5402da541c213cd89c40b7ce7eb3d"><td class="memItemLeft" align="right" valign="top"><a id="ac1f5402da541c213cd89c40b7ce7eb3d"></a>
unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classot_1_1Mesh.html#ac1f5402da541c213cd89c40b7ce7eb3d">getMPICommSizeGlobal</a> () const</td></tr>
<tr class="memdesc:ac1f5402da541c213cd89c40b7ce7eb3d"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns the comm size w.r.t. global comm <br /></td></tr>
<tr class="separator:ac1f5402da541c213cd89c40b7ce7eb3d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad18ff5b7ebf207454daaec963b71e956"><td class="memItemLeft" align="right" valign="top"><a id="ad18ff5b7ebf207454daaec963b71e956"></a>
unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classot_1_1Mesh.html#ad18ff5b7ebf207454daaec963b71e956">getMPIRank</a> () const</td></tr>
<tr class="memdesc:ad18ff5b7ebf207454daaec963b71e956"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns the rank <br /></td></tr>
<tr class="separator:ad18ff5b7ebf207454daaec963b71e956"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a832427dd3f913b5a3b8f85bcad5ba123"><td class="memItemLeft" align="right" valign="top"><a id="a832427dd3f913b5a3b8f85bcad5ba123"></a>
unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classot_1_1Mesh.html#a832427dd3f913b5a3b8f85bcad5ba123">getMPICommSize</a> () const</td></tr>
<tr class="memdesc:a832427dd3f913b5a3b8f85bcad5ba123"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns the comm size: <br /></td></tr>
<tr class="separator:a832427dd3f913b5a3b8f85bcad5ba123"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8751f249eba38736d6a7b043a91af511"><td class="memItemLeft" align="right" valign="top"><a id="a8751f249eba38736d6a7b043a91af511"></a>
const <a class="el" href="classRefElement.html">RefElement</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classot_1_1Mesh.html#a8751f249eba38736d6a7b043a91af511">getReferenceElement</a> () const</td></tr>
<tr class="memdesc:a8751f249eba38736d6a7b043a91af511"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns const pointer to reference element <br /></td></tr>
<tr class="separator:a8751f249eba38736d6a7b043a91af511"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a98ebbdcae5d78bc86b8a6b323c877f25"><td class="memItemLeft" align="right" valign="top"><a id="a98ebbdcae5d78bc86b8a6b323c877f25"></a>
const unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classot_1_1Mesh.html#a98ebbdcae5d78bc86b8a6b323c877f25">getSendProcListSize</a> () const</td></tr>
<tr class="memdesc:a98ebbdcae5d78bc86b8a6b323c877f25"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns the send proc list size <br /></td></tr>
<tr class="separator:a98ebbdcae5d78bc86b8a6b323c877f25"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae1a33c38ba24d9f2ee875a4f92151b8e"><td class="memItemLeft" align="right" valign="top"><a id="ae1a33c38ba24d9f2ee875a4f92151b8e"></a>
const unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classot_1_1Mesh.html#ae1a33c38ba24d9f2ee875a4f92151b8e">getRecvProcListSize</a> () const</td></tr>
<tr class="memdesc:ae1a33c38ba24d9f2ee875a4f92151b8e"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns the recv proc list size <br /></td></tr>
<tr class="separator:ae1a33c38ba24d9f2ee875a4f92151b8e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa6b457c32a23aa5bba7b5910597c928a"><td class="memItemLeft" align="right" valign="top"><a id="aa6b457c32a23aa5bba7b5910597c928a"></a>
const std::vector&lt; unsigned int &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classot_1_1Mesh.html#aa6b457c32a23aa5bba7b5910597c928a">getNodalSendCounts</a> () const</td></tr>
<tr class="memdesc:aa6b457c32a23aa5bba7b5910597c928a"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns the nodal send counts <br /></td></tr>
<tr class="separator:aa6b457c32a23aa5bba7b5910597c928a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae4d5d75c1b949f734ff0bd1e859f269a"><td class="memItemLeft" align="right" valign="top"><a id="ae4d5d75c1b949f734ff0bd1e859f269a"></a>
const std::vector&lt; unsigned int &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classot_1_1Mesh.html#ae4d5d75c1b949f734ff0bd1e859f269a">getNodalSendOffsets</a> () const</td></tr>
<tr class="memdesc:ae4d5d75c1b949f734ff0bd1e859f269a"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns the nodal send offsets <br /></td></tr>
<tr class="separator:ae4d5d75c1b949f734ff0bd1e859f269a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8049cccef0115107923a8fd1d327a528"><td class="memItemLeft" align="right" valign="top"><a id="a8049cccef0115107923a8fd1d327a528"></a>
const std::vector&lt; unsigned int &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classot_1_1Mesh.html#a8049cccef0115107923a8fd1d327a528">getNodalRecvCounts</a> () const</td></tr>
<tr class="memdesc:a8049cccef0115107923a8fd1d327a528"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns the nodal recv counts <br /></td></tr>
<tr class="separator:a8049cccef0115107923a8fd1d327a528"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0644ba460623875f51b2d5651ae4c9b6"><td class="memItemLeft" align="right" valign="top"><a id="a0644ba460623875f51b2d5651ae4c9b6"></a>
const std::vector&lt; unsigned int &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classot_1_1Mesh.html#a0644ba460623875f51b2d5651ae4c9b6">getNodalRecvOffsets</a> () const</td></tr>
<tr class="memdesc:a0644ba460623875f51b2d5651ae4c9b6"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns the nodal recv offsets <br /></td></tr>
<tr class="separator:a0644ba460623875f51b2d5651ae4c9b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a214d6cbd7eaa29bac7cd4f25c48f57b2"><td class="memItemLeft" align="right" valign="top"><a id="a214d6cbd7eaa29bac7cd4f25c48f57b2"></a>
const std::vector&lt; unsigned int &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classot_1_1Mesh.html#a214d6cbd7eaa29bac7cd4f25c48f57b2">getSendProcList</a> () const</td></tr>
<tr class="memdesc:a214d6cbd7eaa29bac7cd4f25c48f57b2"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns the send proc. list <br /></td></tr>
<tr class="separator:a214d6cbd7eaa29bac7cd4f25c48f57b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6ab0849329f2b99c36c0d1bc94ea94d7"><td class="memItemLeft" align="right" valign="top"><a id="a6ab0849329f2b99c36c0d1bc94ea94d7"></a>
const std::vector&lt; unsigned int &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classot_1_1Mesh.html#a6ab0849329f2b99c36c0d1bc94ea94d7">getRecvProcList</a> () const</td></tr>
<tr class="memdesc:a6ab0849329f2b99c36c0d1bc94ea94d7"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns the recv proc. list <br /></td></tr>
<tr class="separator:a6ab0849329f2b99c36c0d1bc94ea94d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a49639c6d49219c9a192d7e86296019d0"><td class="memItemLeft" align="right" valign="top"><a id="a49639c6d49219c9a192d7e86296019d0"></a>
const std::vector&lt; unsigned int &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classot_1_1Mesh.html#a49639c6d49219c9a192d7e86296019d0">getSendNodeSM</a> () const</td></tr>
<tr class="memdesc:a49639c6d49219c9a192d7e86296019d0"><td class="mdescLeft">&#160;</td><td class="mdescRight">return Scatter map for node send <br /></td></tr>
<tr class="separator:a49639c6d49219c9a192d7e86296019d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a863fc4b3b519f537ecaee43031941f03"><td class="memItemLeft" align="right" valign="top"><a id="a863fc4b3b519f537ecaee43031941f03"></a>
const std::vector&lt; unsigned int &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classot_1_1Mesh.html#a863fc4b3b519f537ecaee43031941f03">getRecvNodeSM</a> () const</td></tr>
<tr class="memdesc:a863fc4b3b519f537ecaee43031941f03"><td class="mdescLeft">&#160;</td><td class="mdescRight">return Scatter map for node send <br /></td></tr>
<tr class="separator:a863fc4b3b519f537ecaee43031941f03"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad4a6c6e94fc0b162cb721af901ddfe86"><td class="memItemLeft" align="right" valign="top"><a id="ad4a6c6e94fc0b162cb721af901ddfe86"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classot_1_1Mesh.html#ad4a6c6e94fc0b162cb721af901ddfe86">dg2eijk</a> (unsigned int dg_index, unsigned int &amp;e, unsigned int &amp;i, unsigned int &amp;j, unsigned int &amp;k) const</td></tr>
<tr class="memdesc:ad4a6c6e94fc0b162cb721af901ddfe86"><td class="mdescLeft">&#160;</td><td class="mdescRight">: Decompose the DG index to element id and it's i,j,k values. <br /></td></tr>
<tr class="separator:ad4a6c6e94fc0b162cb721af901ddfe86"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a37b5231494e0fd6fe8e92885c3a2191b"><td class="memItemLeft" align="right" valign="top"><a id="a37b5231494e0fd6fe8e92885c3a2191b"></a>
unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classot_1_1Mesh.html#a37b5231494e0fd6fe8e92885c3a2191b">getMortonchildNum</a> (unsigned int eleID) const</td></tr>
<tr class="memdesc:a37b5231494e0fd6fe8e92885c3a2191b"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns the morton child number <br /></td></tr>
<tr class="separator:a37b5231494e0fd6fe8e92885c3a2191b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a78364a9457af12a9e89a831aaa084faf"><td class="memItemLeft" align="right" valign="top"><a id="a78364a9457af12a9e89a831aaa084faf"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classot_1_1Mesh.html#a78364a9457af12a9e89a831aaa084faf">isActive</a> () const</td></tr>
<tr class="memdesc:a78364a9457af12a9e89a831aaa084faf"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns true if mesh is active <br /></td></tr>
<tr class="separator:a78364a9457af12a9e89a831aaa084faf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acf6cd768bcb7a2e3b5bd6f4f76fb40a2"><td class="memItemLeft" align="right" valign="top"><a id="acf6cd768bcb7a2e3b5bd6f4f76fb40a2"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classot_1_1Mesh.html#acf6cd768bcb7a2e3b5bd6f4f76fb40a2">waitAll</a> () const</td></tr>
<tr class="memdesc:acf6cd768bcb7a2e3b5bd6f4f76fb40a2"><td class="mdescLeft">&#160;</td><td class="mdescRight">waiting for all the mesh instances both active and inactive. This should not be called if not needed. this is a BARRIER. <br /></td></tr>
<tr class="separator:acf6cd768bcb7a2e3b5bd6f4f76fb40a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8abfe4be4d63f1f49ca02016c51e640e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classot_1_1Mesh.html#a8abfe4be4d63f1f49ca02016c51e640e">setOctreeRefineFlags</a> (unsigned int *flags, unsigned int sz)</td></tr>
<tr class="memdesc:a8abfe4be4d63f1f49ca02016c51e640e"><td class="mdescLeft">&#160;</td><td class="mdescRight">set refinement flags for the octree. This is non const function  <a href="#a8abfe4be4d63f1f49ca02016c51e640e">More...</a><br /></td></tr>
<tr class="separator:a8abfe4be4d63f1f49ca02016c51e640e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0961316035d62ce15eb23d2737d1c867"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classot_1_1Mesh.html#a0961316035d62ce15eb23d2737d1c867">getElementalFaceNeighbors</a> (const unsigned int eID, const unsigned int dir, unsigned int *lookup) const</td></tr>
<tr class="memdesc:a0961316035d62ce15eb23d2737d1c867"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns the face neighours in specidied direction.  <a href="#a0961316035d62ce15eb23d2737d1c867">More...</a><br /></td></tr>
<tr class="separator:a0961316035d62ce15eb23d2737d1c867"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad651aeb5e1cf64ae0dd5d85a19e25e46"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classot_1_1Mesh.html#ad651aeb5e1cf64ae0dd5d85a19e25e46">getElementalEdgeNeighbors</a> (const unsigned int eID, const unsigned int dir, unsigned int *lookup) const</td></tr>
<tr class="memdesc:ad651aeb5e1cf64ae0dd5d85a19e25e46"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns the edge neighours in specidied direction.  <a href="#ad651aeb5e1cf64ae0dd5d85a19e25e46">More...</a><br /></td></tr>
<tr class="separator:ad651aeb5e1cf64ae0dd5d85a19e25e46"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad7e40d1f1ec1f900f47a993a884d85db"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classot_1_1Mesh.html#ad7e40d1f1ec1f900f47a993a884d85db">getElementalVertexNeighbors</a> (const unsigned int eID, const unsigned int dir, unsigned int *lookup) const</td></tr>
<tr class="memdesc:ad7e40d1f1ec1f900f47a993a884d85db"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns the vertex neighours in specidied direction.  <a href="#ad7e40d1f1ec1f900f47a993a884d85db">More...</a><br /></td></tr>
<tr class="separator:ad7e40d1f1ec1f900f47a993a884d85db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a182c1dc2ed3594bbfb125675a4fb7163"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classot_1_1Mesh.html#a182c1dc2ed3594bbfb125675a4fb7163">getElementQMat</a> (unsigned int currentId, double *&amp;qMat, bool isAllocated=true) const</td></tr>
<tr class="memdesc:a182c1dc2ed3594bbfb125675a4fb7163"><td class="mdescLeft">&#160;</td><td class="mdescRight">: Compute the elemental interpolation matrix.  <a href="#a182c1dc2ed3594bbfb125675a4fb7163">More...</a><br /></td></tr>
<tr class="separator:a182c1dc2ed3594bbfb125675a4fb7163"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8f2a75446405e404398ea8ff99102ff5"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a8f2a75446405e404398ea8ff99102ff5"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classot_1_1Mesh.html#a8f2a75446405e404398ea8ff99102ff5">getUnzipElementalNodalValues</a> (const T *uzipVec, unsigned int blkID, unsigned int ele, T *out, bool isPadded=true) const</td></tr>
<tr class="memdesc:a8f2a75446405e404398ea8ff99102ff5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the elemental nodal values using unzip representation of the array.  <a href="#a8f2a75446405e404398ea8ff99102ff5">More...</a><br /></td></tr>
<tr class="separator:a8f2a75446405e404398ea8ff99102ff5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6ead4df754f5210caf33c01776d9344b"><td class="memTemplParams" colspan="2"><a id="a6ead4df754f5210caf33c01776d9344b"></a>
template&lt;ot::WaveletDA::LoopType type&gt; </td></tr>
<tr class="memitem:a6ead4df754f5210caf33c01776d9344b"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classot_1_1Mesh.html#a6ead4df754f5210caf33c01776d9344b">init</a> ()</td></tr>
<tr class="memdesc:a6ead4df754f5210caf33c01776d9344b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initilizes the wavelet <a class="el" href="classot_1_1DA.html">DA</a> loop depending on the WaveletDA flags specified. <br /></td></tr>
<tr class="separator:a6ead4df754f5210caf33c01776d9344b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4f738f0ac7009c8469d0d1d4f45cc181"><td class="memTemplParams" colspan="2"><a id="a4f738f0ac7009c8469d0d1d4f45cc181"></a>
template&lt;ot::WaveletDA::LoopType type&gt; </td></tr>
<tr class="memitem:a4f738f0ac7009c8469d0d1d4f45cc181"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classot_1_1Mesh.html#a4f738f0ac7009c8469d0d1d4f45cc181">nextAvailable</a> ()</td></tr>
<tr class="memdesc:a4f738f0ac7009c8469d0d1d4f45cc181"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check whether the next element is available. <br /></td></tr>
<tr class="separator:a4f738f0ac7009c8469d0d1d4f45cc181"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad390570f47f6bee2cdd809ec96f03b69"><td class="memTemplParams" colspan="2"><a id="ad390570f47f6bee2cdd809ec96f03b69"></a>
template&lt;ot::WaveletDA::LoopType type&gt; </td></tr>
<tr class="memitem:ad390570f47f6bee2cdd809ec96f03b69"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classot_1_1Mesh.html#ad390570f47f6bee2cdd809ec96f03b69">next</a> ()</td></tr>
<tr class="memdesc:ad390570f47f6bee2cdd809ec96f03b69"><td class="mdescLeft">&#160;</td><td class="mdescRight">Increment the counters to access the next element in the mesh. <br /></td></tr>
<tr class="separator:ad390570f47f6bee2cdd809ec96f03b69"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3a08dd438002b8f1e3983d453a6ff128"><td class="memItemLeft" align="right" valign="top"><a id="a3a08dd438002b8f1e3983d453a6ff128"></a>
const <a class="el" href="classot_1_1TreeNode.html">ot::TreeNode</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classot_1_1Mesh.html#a3a08dd438002b8f1e3983d453a6ff128">currentOctant</a> ()</td></tr>
<tr class="memdesc:a3a08dd438002b8f1e3983d453a6ff128"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the current element as an octant. <br /></td></tr>
<tr class="separator:a3a08dd438002b8f1e3983d453a6ff128"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ada231433a4fb7f652d5f08143adce8ca"><td class="memItemLeft" align="right" valign="top"><a id="ada231433a4fb7f652d5f08143adce8ca"></a>
unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classot_1_1Mesh.html#ada231433a4fb7f652d5f08143adce8ca">currentIndex</a> ()</td></tr>
<tr class="memdesc:ada231433a4fb7f652d5f08143adce8ca"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the current element index. <br /></td></tr>
<tr class="separator:ada231433a4fb7f652d5f08143adce8ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0723701a73d877bcefe016c674daca18"><td class="memItemLeft" align="right" valign="top"><a id="a0723701a73d877bcefe016c674daca18"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classot_1_1Mesh.html#a0723701a73d877bcefe016c674daca18">currentElementNeighbourIndexList</a> (unsigned int *neighList)</td></tr>
<tr class="memdesc:a0723701a73d877bcefe016c674daca18"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the current neighbour list (Element) information. Note that for 3D it is 8 neighbours for each octant and for 2D it is 4. <br /></td></tr>
<tr class="separator:a0723701a73d877bcefe016c674daca18"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a06e81eae5a40df05d9818a1da0b060d8"><td class="memItemLeft" align="right" valign="top"><a id="a06e81eae5a40df05d9818a1da0b060d8"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classot_1_1Mesh.html#a06e81eae5a40df05d9818a1da0b060d8">currentElementNodeList</a> (unsigned int *nodeList)</td></tr>
<tr class="memdesc:a06e81eae5a40df05d9818a1da0b060d8"><td class="mdescLeft">&#160;</td><td class="mdescRight">: Returns the node index list belongs to current element. NodeList size should be m_uiNpE; <br /></td></tr>
<tr class="separator:a06e81eae5a40df05d9818a1da0b060d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a94c6066fe664e0539ddc490cf7ffaadc"><td class="memItemLeft" align="right" valign="top"><a id="a94c6066fe664e0539ddc490cf7ffaadc"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classot_1_1Mesh.html#a94c6066fe664e0539ddc490cf7ffaadc">currentElementNodeList_DG</a> (unsigned int *nodeList)</td></tr>
<tr class="memdesc:a94c6066fe664e0539ddc490cf7ffaadc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the node index list belogns to the currentl element in DG indexing. NodeList size should be m_uiNpE;. <br /></td></tr>
<tr class="separator:a94c6066fe664e0539ddc490cf7ffaadc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa5fed0ceb0f52016afd86537d60a09df"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classot_1_1Mesh.html#aa5fed0ceb0f52016afd86537d60a09df">faceNodesIndex</a> (unsigned int elementID, unsigned int face, std::vector&lt; unsigned int &gt; &amp;index, bool isInternal) const</td></tr>
<tr class="memdesc:aa5fed0ceb0f52016afd86537d60a09df"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the index of m_uiE2NMapping (CG or DG) for a specified face.  <a href="#aa5fed0ceb0f52016afd86537d60a09df">More...</a><br /></td></tr>
<tr class="separator:aa5fed0ceb0f52016afd86537d60a09df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a41cd588a236f94cb3f0a794ebb097cae"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classot_1_1Mesh.html#a41cd588a236f94cb3f0a794ebb097cae">edgeNodeIndex</a> (unsigned int elementID, unsigned int face1, unsigned int face2, std::vector&lt; unsigned int &gt; &amp;index, bool isInternal) const</td></tr>
<tr class="memdesc:a41cd588a236f94cb3f0a794ebb097cae"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the index of m_uiE2NMapping (CG or DG) for a specified Edge.  <a href="#a41cd588a236f94cb3f0a794ebb097cae">More...</a><br /></td></tr>
<tr class="separator:a41cd588a236f94cb3f0a794ebb097cae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6c574cbdf74920ea3d72e211104667fc"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classot_1_1Mesh.html#a6c574cbdf74920ea3d72e211104667fc">cornerNodeIndex</a> (unsigned int elementID, unsigned int mortonIndex, unsigned int &amp;index) const</td></tr>
<tr class="memdesc:a6c574cbdf74920ea3d72e211104667fc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the index of m_uiE2NMapping (CG or DG) for a specified Edge.  <a href="#a6c574cbdf74920ea3d72e211104667fc">More...</a><br /></td></tr>
<tr class="separator:a6c574cbdf74920ea3d72e211104667fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4de13b90a7ff62e7c3ee13832d485a07"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classot_1_1Mesh.html#a4de13b90a7ff62e7c3ee13832d485a07">elementNodeIndex</a> (unsigned int elementID, std::vector&lt; unsigned int &gt; &amp;index, bool isInternal) const</td></tr>
<tr class="memdesc:a4de13b90a7ff62e7c3ee13832d485a07"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the all the internal node indices of an element.  <a href="#a4de13b90a7ff62e7c3ee13832d485a07">More...</a><br /></td></tr>
<tr class="separator:a4de13b90a7ff62e7c3ee13832d485a07"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a89590df87eb14c8ed68512ab2c5ab0ce"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classot_1_1Mesh.html#a89590df87eb14c8ed68512ab2c5ab0ce">isEdgeHanging</a> (unsigned int elementId, unsigned int edgeId, unsigned int &amp;cnum) const</td></tr>
<tr class="memdesc:a89590df87eb14c8ed68512ab2c5ab0ce"><td class="mdescLeft">&#160;</td><td class="mdescRight">: Returns true or false (bases on specified edge is hanging or not.)for a given element id , and edge id.  <a href="#a89590df87eb14c8ed68512ab2c5ab0ce">More...</a><br /></td></tr>
<tr class="separator:a89590df87eb14c8ed68512ab2c5ab0ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abbaaa964ec14c760646e1de13df51479"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classot_1_1Mesh.html#abbaaa964ec14c760646e1de13df51479">isFaceHanging</a> (unsigned int elementId, unsigned int faceId, unsigned int &amp;cnum) const</td></tr>
<tr class="memdesc:abbaaa964ec14c760646e1de13df51479"><td class="mdescLeft">&#160;</td><td class="mdescRight">: Returns true or false (bases on specified edge is hanging or not.)for a given element id , and edge id.  <a href="#abbaaa964ec14c760646e1de13df51479">More...</a><br /></td></tr>
<tr class="separator:abbaaa964ec14c760646e1de13df51479"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa3cdef1614570f1b22318e3fd8923468"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classot_1_1Mesh.html#aa3cdef1614570f1b22318e3fd8923468">isNodeHanging</a> (unsigned int eleID, unsigned int ix, unsigned int jy, unsigned int kz) const</td></tr>
<tr class="memdesc:aa3cdef1614570f1b22318e3fd8923468"><td class="mdescLeft">&#160;</td><td class="mdescRight">: Returns true if the specified node (e,i,j,k) is hanging.  <a href="#aa3cdef1614570f1b22318e3fd8923468">More...</a><br /></td></tr>
<tr class="separator:aa3cdef1614570f1b22318e3fd8923468"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a348335b97cb0491aec2168ede75aa2fe"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classot_1_1Mesh.html#a348335b97cb0491aec2168ede75aa2fe">isNodeLocal</a> (unsigned int eleID, unsigned int ix, unsigned int jy, unsigned int kz) const</td></tr>
<tr class="memdesc:a348335b97cb0491aec2168ede75aa2fe"><td class="mdescLeft">&#160;</td><td class="mdescRight">: Returns true if the specified node (e,i,j,k) is local.  <a href="#a348335b97cb0491aec2168ede75aa2fe">More...</a><br /></td></tr>
<tr class="separator:a348335b97cb0491aec2168ede75aa2fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab78136c401f362e7b89cd1e685442e32"><td class="memItemLeft" align="right" valign="top"><a id="ab78136c401f362e7b89cd1e685442e32"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>isBoundaryOctant</b> (unsigned int ele) const</td></tr>
<tr class="separator:ab78136c401f362e7b89cd1e685442e32"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9fcc81fb5e2e2e2f62d62fac337a4c78"><td class="memItemLeft" align="right" valign="top"><a id="a9fcc81fb5e2e2e2f62d62fac337a4c78"></a>
DendroIntL&#160;</td><td class="memItemRight" valign="bottom"><b>getGhostExcgTotalSendNodeCount</b> () const</td></tr>
<tr class="separator:a9fcc81fb5e2e2e2f62d62fac337a4c78"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab0936eee3eb7942efe339a714b0fede1"><td class="memItemLeft" align="right" valign="top"><a id="ab0936eee3eb7942efe339a714b0fede1"></a>
DendroIntL&#160;</td><td class="memItemRight" valign="bottom"><b>getGhostExcgTotalRecvNodeCount</b> () const</td></tr>
<tr class="separator:ab0936eee3eb7942efe339a714b0fede1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a05eb784b4d5ee4d8e26e1856d0423dcd"><td class="memItemLeft" align="right" valign="top"><a id="a05eb784b4d5ee4d8e26e1856d0423dcd"></a>
const <a class="el" href="classot_1_1TreeNode.html">ot::TreeNode</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classot_1_1Mesh.html#a05eb784b4d5ee4d8e26e1856d0423dcd">getNodalSplitterNodes</a> () const</td></tr>
<tr class="memdesc:a05eb784b4d5ee4d8e26e1856d0423dcd"><td class="mdescLeft">&#160;</td><td class="mdescRight">get plitter nodes for each processor. <br /></td></tr>
<tr class="separator:a05eb784b4d5ee4d8e26e1856d0423dcd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a66a8dd8fdc67eabb632459b938cf2342"><td class="memTemplParams" colspan="2"><a id="a66a8dd8fdc67eabb632459b938cf2342"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a66a8dd8fdc67eabb632459b938cf2342"><td class="memTemplItemLeft" align="right" valign="top">T *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classot_1_1Mesh.html#a66a8dd8fdc67eabb632459b938cf2342">createVector</a> () const</td></tr>
<tr class="memdesc:a66a8dd8fdc67eabb632459b938cf2342"><td class="mdescLeft">&#160;</td><td class="mdescRight">allocate memory for variable array based on the adaptive mesh <br /></td></tr>
<tr class="separator:a66a8dd8fdc67eabb632459b938cf2342"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a59d725bfc57d448c1a5648ad595485d4"><td class="memTemplParams" colspan="2"><a id="a59d725bfc57d448c1a5648ad595485d4"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a59d725bfc57d448c1a5648ad595485d4"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classot_1_1Mesh.html#a59d725bfc57d448c1a5648ad595485d4">createVector</a> (std::vector&lt; T &gt; &amp;vec) const</td></tr>
<tr class="memdesc:a59d725bfc57d448c1a5648ad595485d4"><td class="mdescLeft">&#160;</td><td class="mdescRight">allocate memory for variable array based on the adaptive mesh. <br /></td></tr>
<tr class="separator:a59d725bfc57d448c1a5648ad595485d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae747a8f9fd5af2f997574517370a2f09"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ae747a8f9fd5af2f997574517370a2f09"><td class="memTemplItemLeft" align="right" valign="top">T *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classot_1_1Mesh.html#ae747a8f9fd5af2f997574517370a2f09">createVector</a> (const T initValue) const</td></tr>
<tr class="memdesc:ae747a8f9fd5af2f997574517370a2f09"><td class="mdescLeft">&#160;</td><td class="mdescRight">allocate memory for variable array based on the adaptive mesh.  <a href="#ae747a8f9fd5af2f997574517370a2f09">More...</a><br /></td></tr>
<tr class="separator:ae747a8f9fd5af2f997574517370a2f09"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab6fcb246647cec17192e6e9cd48569cc"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ab6fcb246647cec17192e6e9cd48569cc"><td class="memTemplItemLeft" align="right" valign="top">T *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classot_1_1Mesh.html#ab6fcb246647cec17192e6e9cd48569cc">createVector</a> (std::function&lt; T(T, T, T)&gt; func) const</td></tr>
<tr class="memdesc:ab6fcb246647cec17192e6e9cd48569cc"><td class="mdescLeft">&#160;</td><td class="mdescRight">allocate memory for variable array based on the adaptive mesh.  <a href="#ab6fcb246647cec17192e6e9cd48569cc">More...</a><br /></td></tr>
<tr class="separator:ab6fcb246647cec17192e6e9cd48569cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae27a7956c08a0511a5a4640b9c1bef81"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ae27a7956c08a0511a5a4640b9c1bef81"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classot_1_1Mesh.html#ae27a7956c08a0511a5a4640b9c1bef81">createVector</a> (std::vector&lt; T &gt; &amp;vec, const T initValue) const</td></tr>
<tr class="memdesc:ae27a7956c08a0511a5a4640b9c1bef81"><td class="mdescLeft">&#160;</td><td class="mdescRight">allocate memory for variable array based on the adaptive mesh.  <a href="#ae27a7956c08a0511a5a4640b9c1bef81">More...</a><br /></td></tr>
<tr class="separator:ae27a7956c08a0511a5a4640b9c1bef81"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af30ed1bc43510824f41a62591a3e0038"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:af30ed1bc43510824f41a62591a3e0038"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classot_1_1Mesh.html#af30ed1bc43510824f41a62591a3e0038">createVector</a> (std::vector&lt; T &gt; &amp;vec, std::function&lt; T(T, T, T)&gt; func) const</td></tr>
<tr class="memdesc:af30ed1bc43510824f41a62591a3e0038"><td class="mdescLeft">&#160;</td><td class="mdescRight">create and initialize local elements based on a given function.  <a href="#af30ed1bc43510824f41a62591a3e0038">More...</a><br /></td></tr>
<tr class="separator:af30ed1bc43510824f41a62591a3e0038"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a27f7b90e19c5d5e0dc2e8f2251547994"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a27f7b90e19c5d5e0dc2e8f2251547994"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classot_1_1Mesh.html#a27f7b90e19c5d5e0dc2e8f2251547994">createUnZippedVector</a> (std::vector&lt; T &gt; &amp;uvec) const</td></tr>
<tr class="memdesc:a27f7b90e19c5d5e0dc2e8f2251547994"><td class="mdescLeft">&#160;</td><td class="mdescRight">: creates (memory allocation) for the unzipped version of the vector.  <a href="#a27f7b90e19c5d5e0dc2e8f2251547994">More...</a><br /></td></tr>
<tr class="separator:a27f7b90e19c5d5e0dc2e8f2251547994"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3d06161d424da408bc13b081682fd258"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a3d06161d424da408bc13b081682fd258"><td class="memTemplItemLeft" align="right" valign="top">T *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classot_1_1Mesh.html#a3d06161d424da408bc13b081682fd258">createUnZippedVector</a> () const</td></tr>
<tr class="memdesc:a3d06161d424da408bc13b081682fd258"><td class="mdescLeft">&#160;</td><td class="mdescRight">: creates (memory allocation) for the unzipped version of the vector.  <a href="#a3d06161d424da408bc13b081682fd258">More...</a><br /></td></tr>
<tr class="separator:a3d06161d424da408bc13b081682fd258"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac67aa1cf985e121ef3adbf33bf5f5a92"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ac67aa1cf985e121ef3adbf33bf5f5a92"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classot_1_1Mesh.html#ac67aa1cf985e121ef3adbf33bf5f5a92">createUnZippedVector</a> (std::vector&lt; T &gt; &amp;uvec, const T initValue) const</td></tr>
<tr class="memdesc:ac67aa1cf985e121ef3adbf33bf5f5a92"><td class="mdescLeft">&#160;</td><td class="mdescRight">allocate memory for variable array based on the adaptive mesh.  <a href="#ac67aa1cf985e121ef3adbf33bf5f5a92">More...</a><br /></td></tr>
<tr class="separator:ac67aa1cf985e121ef3adbf33bf5f5a92"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a249b4a2d1852bb354a0b325a0b0112e3"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a249b4a2d1852bb354a0b325a0b0112e3"><td class="memTemplItemLeft" align="right" valign="top">T *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classot_1_1Mesh.html#a249b4a2d1852bb354a0b325a0b0112e3">createUnZippedVector</a> (const T initValue) const</td></tr>
<tr class="memdesc:a249b4a2d1852bb354a0b325a0b0112e3"><td class="mdescLeft">&#160;</td><td class="mdescRight">allocate memory for variable array based on the adaptive mesh.  <a href="#a249b4a2d1852bb354a0b325a0b0112e3">More...</a><br /></td></tr>
<tr class="separator:a249b4a2d1852bb354a0b325a0b0112e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a698c8e504453e26d3fb7297fa9a1d432"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classot_1_1Mesh.html#a698c8e504453e26d3fb7297fa9a1d432">parent2ChildInterpolation</a> (const double *in, double *out, unsigned int cnum, unsigned int dim=3) const</td></tr>
<tr class="memdesc:a698c8e504453e26d3fb7297fa9a1d432"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs all parent to child interpolations for the m_uiEl_i element in order to apply the stencil.  <a href="#a698c8e504453e26d3fb7297fa9a1d432">More...</a><br /></td></tr>
<tr class="separator:a698c8e504453e26d3fb7297fa9a1d432"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4126c5fc333598f60b04ab59a6205d64"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classot_1_1Mesh.html#a4126c5fc333598f60b04ab59a6205d64">child2ParentInterpolation</a> (const double *in, double *out, unsigned int cnum, unsigned int dim=3) const</td></tr>
<tr class="memdesc:a4126c5fc333598f60b04ab59a6205d64"><td class="mdescLeft">&#160;</td><td class="mdescRight">performs the child to parent contribution (only from a single child).  <a href="#a4126c5fc333598f60b04ab59a6205d64">More...</a><br /></td></tr>
<tr class="separator:a4126c5fc333598f60b04ab59a6205d64"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a30e31c8e5add5344bfaa42aadf4d7ec3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classot_1_1Mesh.html#a30e31c8e5add5344bfaa42aadf4d7ec3">child2ParentInjection</a> (double *in, double *out, bool *isHanging) const</td></tr>
<tr class="memdesc:a30e31c8e5add5344bfaa42aadf4d7ec3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs child to parent injection.  <a href="#a30e31c8e5add5344bfaa42aadf4d7ec3">More...</a><br /></td></tr>
<tr class="separator:a30e31c8e5add5344bfaa42aadf4d7ec3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9c30826c0278b278cfd20034ac531c8e"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a9c30826c0278b278cfd20034ac531c8e"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classot_1_1Mesh.html#a9c30826c0278b278cfd20034ac531c8e">unzip</a> (const T *zippedVec, T *unzippedVec)</td></tr>
<tr class="memdesc:a9c30826c0278b278cfd20034ac531c8e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates the decomposition of adaptive octree variables into blocklist variables that we computed.  <a href="#a9c30826c0278b278cfd20034ac531c8e">More...</a><br /></td></tr>
<tr class="separator:a9c30826c0278b278cfd20034ac531c8e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a45df9f6bb4dc2d73a675abaab087b076"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a45df9f6bb4dc2d73a675abaab087b076"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classot_1_1Mesh.html#a45df9f6bb4dc2d73a675abaab087b076">unzip_async</a> (T *zippedVec, T *unzippedVec, MPI_Request *send_reqs, MPI_Request *recv_reqs, MPI_Status *send_sts, MPI_Status *recv_sts)</td></tr>
<tr class="memdesc:a45df9f6bb4dc2d73a675abaab087b076"><td class="mdescLeft">&#160;</td><td class="mdescRight">perform the unzip operation overlap with the communication. GHOST exchage done inside. User doesn't need to perofrm ghost exchange.  <a href="#a45df9f6bb4dc2d73a675abaab087b076">More...</a><br /></td></tr>
<tr class="separator:a45df9f6bb4dc2d73a675abaab087b076"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6ef4ca39831332f297029d067c7ed471"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a6ef4ca39831332f297029d067c7ed471"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classot_1_1Mesh.html#a6ef4ca39831332f297029d067c7ed471">zip</a> (const T *unzippedVec, T *zippedVec)</td></tr>
<tr class="memdesc:a6ef4ca39831332f297029d067c7ed471"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs the compression frrom regular block grid varable list to adaptive representation.  <a href="#a6ef4ca39831332f297029d067c7ed471">More...</a><br /></td></tr>
<tr class="separator:a6ef4ca39831332f297029d067c7ed471"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab581c5ad4b179a08016433ff39623621"><td class="memTemplParams" colspan="2">template&lt;typename T , unsigned int length, unsigned int offsetCentered, unsigned int offsetBackward, unsigned int offsetForward&gt; </td></tr>
<tr class="memitem:ab581c5ad4b179a08016433ff39623621"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classot_1_1Mesh.html#ab581c5ad4b179a08016433ff39623621">applyStencil</a> (const std::vector&lt; T &gt; &amp;in, std::vector&lt; T &gt; &amp;out, const <a class="el" href="structStencil.html">Stencil</a>&lt; T, length, offsetCentered &gt; &amp;centered, const <a class="el" href="structStencil.html">Stencil</a>&lt; T, length, offsetBackward &gt; &amp;backward, const <a class="el" href="structStencil.html">Stencil</a>&lt; T, length, offsetForward &gt; &amp;forward)</td></tr>
<tr class="memdesc:ab581c5ad4b179a08016433ff39623621"><td class="mdescLeft">&#160;</td><td class="mdescRight">Apply a given stencil to for provided variable array.  <a href="#ab581c5ad4b179a08016433ff39623621">More...</a><br /></td></tr>
<tr class="separator:ab581c5ad4b179a08016433ff39623621"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a51f2933622bf3219aed13a3506dd35dd"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a51f2933622bf3219aed13a3506dd35dd"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classot_1_1Mesh.html#a51f2933622bf3219aed13a3506dd35dd">performGhostExchange</a> (std::vector&lt; T &gt; &amp;vec)</td></tr>
<tr class="memdesc:a51f2933622bf3219aed13a3506dd35dd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Perform the ghost exchange for the vector vec.  <a href="#a51f2933622bf3219aed13a3506dd35dd">More...</a><br /></td></tr>
<tr class="separator:a51f2933622bf3219aed13a3506dd35dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af7487d05c4f0c6aa0e8ea7c99e10ad40"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:af7487d05c4f0c6aa0e8ea7c99e10ad40"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classot_1_1Mesh.html#af7487d05c4f0c6aa0e8ea7c99e10ad40">performGhostExchange</a> (T *vec)</td></tr>
<tr class="memdesc:af7487d05c4f0c6aa0e8ea7c99e10ad40"><td class="mdescLeft">&#160;</td><td class="mdescRight">Perform the ghost exchange for the vector vec.  <a href="#af7487d05c4f0c6aa0e8ea7c99e10ad40">More...</a><br /></td></tr>
<tr class="separator:af7487d05c4f0c6aa0e8ea7c99e10ad40"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6699c141d1b3be3ab04cde54b3f5bf09"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a6699c141d1b3be3ab04cde54b3f5bf09"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classot_1_1Mesh.html#a6699c141d1b3be3ab04cde54b3f5bf09">ghostExchangeStart</a> (T *vec, T *sendNodeBuffer, T *recvNodeBuffer, MPI_Request *send_reqs, MPI_Request *recv_reqs)</td></tr>
<tr class="memdesc:a6699c141d1b3be3ab04cde54b3f5bf09"><td class="mdescLeft">&#160;</td><td class="mdescRight">Perform the ghost asynchronous send for the vector vec Note: this is a non-blocking asynchronous communication. User is resposible to call the (synchronous call such as MPI_WaitAll) when overlapping the communication and computation.  <a href="#a6699c141d1b3be3ab04cde54b3f5bf09">More...</a><br /></td></tr>
<tr class="separator:a6699c141d1b3be3ab04cde54b3f5bf09"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae7bf4daff7f8f951836236c1138b9cc7"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ae7bf4daff7f8f951836236c1138b9cc7"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classot_1_1Mesh.html#ae7bf4daff7f8f951836236c1138b9cc7">ghostExchangeRecvSync</a> (T *vec, T *recvNodeBuffer, MPI_Request *recv_reqs, MPI_Status *recv_sts)</td></tr>
<tr class="memdesc:ae7bf4daff7f8f951836236c1138b9cc7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Perform the wait on the recv requests.  <a href="#ae7bf4daff7f8f951836236c1138b9cc7">More...</a><br /></td></tr>
<tr class="separator:ae7bf4daff7f8f951836236c1138b9cc7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af42b22f6abbedd20a695cb73bab7f3cb"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classot_1_1Mesh.html#af42b22f6abbedd20a695cb73bab7f3cb">ghostExchangeSendSync</a> (MPI_Request *send_reqs, MPI_Status *send_sts)</td></tr>
<tr class="memdesc:af42b22f6abbedd20a695cb73bab7f3cb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Perform the wait on the recv requests.  <a href="#af42b22f6abbedd20a695cb73bab7f3cb">More...</a><br /></td></tr>
<tr class="separator:af42b22f6abbedd20a695cb73bab7f3cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1d89ba02e9b09ed5fe44d1c2c734daf5"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a1d89ba02e9b09ed5fe44d1c2c734daf5"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classot_1_1Mesh.html#a1d89ba02e9b09ed5fe44d1c2c734daf5">vectorToVTK</a> (const std::vector&lt; T &gt; &amp;vec, char *fprefix, double pTime=0.0, unsigned int nCycle=0) const</td></tr>
<tr class="memdesc:a1d89ba02e9b09ed5fe44d1c2c734daf5"><td class="mdescLeft">&#160;</td><td class="mdescRight">write out function values to a vtk file.  <a href="#a1d89ba02e9b09ed5fe44d1c2c734daf5">More...</a><br /></td></tr>
<tr class="separator:a1d89ba02e9b09ed5fe44d1c2c734daf5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb87fe8ef3f3e3e3029588ec6e0d7d07"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:aeb87fe8ef3f3e3e3029588ec6e0d7d07"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classot_1_1Mesh.html#aeb87fe8ef3f3e3e3029588ec6e0d7d07">isReMesh</a> (const T **vec, const unsigned int *varIds, const unsigned int numVars, double tol, double amr_coarse_fac=DENDRO_AMR_COARSEN_FAC)</td></tr>
<tr class="memdesc:aeb87fe8ef3f3e3e3029588ec6e0d7d07"><td class="mdescLeft">&#160;</td><td class="mdescRight">: determine whether any refinement or coarsening need for a specified set of elements. (This uses zipped version of the varibles which needs to satiesfy some constraints. Not every element is eligible for refinemenet or coarsening).  <a href="#aeb87fe8ef3f3e3e3029588ec6e0d7d07">More...</a><br /></td></tr>
<tr class="separator:aeb87fe8ef3f3e3e3029588ec6e0d7d07"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af6a16defebca50f647744e066aef8612"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:af6a16defebca50f647744e066aef8612"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classot_1_1Mesh.html#af6a16defebca50f647744e066aef8612">isReMeshUnzip</a> (const T **unzippedVec, const unsigned int *varIds, const unsigned int numVars, std::function&lt; double(double, double, double)&gt; wavelet_tol, double amr_coarse_fac=DENDRO_AMR_COARSEN_FAC, double coarsen_hx=DENDRO_REMESH_UNZIP_SCALE_FAC)</td></tr>
<tr class="separator:af6a16defebca50f647744e066aef8612"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4025c805748265bf29a792dcddafb783"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classot_1_1Mesh.html">ot::Mesh</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classot_1_1Mesh.html#a4025c805748265bf29a792dcddafb783">ReMesh</a> (unsigned int grainSz=DENDRO_DEFAULT_GRAIN_SZ, double ld_tol=DENDRO_DEFAULT_LB_TOL, unsigned int sfK=DENDRO_DEFAULT_SF_K, unsigned int(*getWeight)(const <a class="el" href="classot_1_1TreeNode.html">ot::TreeNode</a> *)=NULL)</td></tr>
<tr class="memdesc:a4025c805748265bf29a792dcddafb783"><td class="mdescLeft">&#160;</td><td class="mdescRight">: Remesh the mesh with the new computed elements.  <a href="#a4025c805748265bf29a792dcddafb783">More...</a><br /></td></tr>
<tr class="separator:a4025c805748265bf29a792dcddafb783"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1dcdbec00948fa92004b9861fe45286d"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a1dcdbec00948fa92004b9861fe45286d"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classot_1_1Mesh.html#a1dcdbec00948fa92004b9861fe45286d">interGridTransfer</a> (std::vector&lt; T &gt; &amp;vec, const <a class="el" href="classot_1_1Mesh.html">ot::Mesh</a> *pMesh)</td></tr>
<tr class="memdesc:a1dcdbec00948fa92004b9861fe45286d"><td class="mdescLeft">&#160;</td><td class="mdescRight">transfer a variable vector form old grid to new grid.  <a href="#a1dcdbec00948fa92004b9861fe45286d">More...</a><br /></td></tr>
<tr class="separator:a1dcdbec00948fa92004b9861fe45286d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a18778d695759db6c74ef839261f2ce3f"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a18778d695759db6c74ef839261f2ce3f"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classot_1_1Mesh.html#a18778d695759db6c74ef839261f2ce3f">interGridTransfer</a> (T *&amp;vec, const <a class="el" href="classot_1_1Mesh.html">ot::Mesh</a> *pMesh)</td></tr>
<tr class="memdesc:a18778d695759db6c74ef839261f2ce3f"><td class="mdescLeft">&#160;</td><td class="mdescRight">transfer a variable vector form old grid to new grid.  <a href="#a18778d695759db6c74ef839261f2ce3f">More...</a><br /></td></tr>
<tr class="separator:a18778d695759db6c74ef839261f2ce3f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5a314de88bd7759895f836445537c9e5"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a5a314de88bd7759895f836445537c9e5"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classot_1_1Mesh.html#a5a314de88bd7759895f836445537c9e5">interGridTransferUnzip</a> (T *&amp;<a class="el" href="classot_1_1Mesh.html#a9c30826c0278b278cfd20034ac531c8e">unzip</a>, T *&amp;vec, const <a class="el" href="classot_1_1Mesh.html">ot::Mesh</a> *pMesh)</td></tr>
<tr class="memdesc:a5a314de88bd7759895f836445537c9e5"><td class="mdescLeft">&#160;</td><td class="mdescRight">performs the intergrid transfer operation using the unzip representation. Compared to elemental intergrid transfer this uses information from neighbouring elements while the transfer occurs.  <a href="#a5a314de88bd7759895f836445537c9e5">More...</a><br /></td></tr>
<tr class="separator:a5a314de88bd7759895f836445537c9e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaef546805498f31c6ad9b77383fa14d5"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:aaef546805498f31c6ad9b77383fa14d5"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classot_1_1Mesh.html#aaef546805498f31c6ad9b77383fa14d5">getElementNodalValues</a> (const T *vec, T *nodalValues, unsigned int elementID) const</td></tr>
<tr class="memdesc:aaef546805498f31c6ad9b77383fa14d5"><td class="mdescLeft">&#160;</td><td class="mdescRight">: Returns the nodal values of a given element for a given variable vector.  <a href="#aaef546805498f31c6ad9b77383fa14d5">More...</a><br /></td></tr>
<tr class="separator:aaef546805498f31c6ad9b77383fa14d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a55788ff265719f60255af54e00ecb194"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a55788ff265719f60255af54e00ecb194"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classot_1_1Mesh.html#a55788ff265719f60255af54e00ecb194">computeElementalContribution</a> (const T *in, T *out, unsigned int elementID) const</td></tr>
<tr class="memdesc:a55788ff265719f60255af54e00ecb194"><td class="mdescLeft">&#160;</td><td class="mdescRight">: Computes the contribution of elemental nodal values to the parent elements if it is hanging. Note: internal nodes for the elements cannnot be hagging. Only the face edge nodes are possible for hanging.  <a href="#a55788ff265719f60255af54e00ecb194">More...</a><br /></td></tr>
<tr class="separator:a55788ff265719f60255af54e00ecb194"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6f95392f47adaf1fe8f10d76217b972f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classot_1_1Mesh.html#a6f95392f47adaf1fe8f10d76217b972f">getElementCoordinates</a> (unsigned int eleID, double *coords) const</td></tr>
<tr class="memdesc:a6f95392f47adaf1fe8f10d76217b972f"><td class="mdescLeft">&#160;</td><td class="mdescRight">computes the elementCoordinates (based on the nodal placement)  <a href="#a6f95392f47adaf1fe8f10d76217b972f">More...</a><br /></td></tr>
<tr class="separator:a6f95392f47adaf1fe8f10d76217b972f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6d3b5d0cc1fd456d43de3bf918d3caee"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a6d3b5d0cc1fd456d43de3bf918d3caee"><td class="memTemplItemLeft" align="right" valign="top">int&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classot_1_1Mesh.html#a6d3b5d0cc1fd456d43de3bf918d3caee">getFaceNeighborValues</a> (unsigned int eleID, const T *in, T *out, T *coords, unsigned int *neighID, unsigned int face, NeighbourLevel &amp;level) const</td></tr>
<tr class="memdesc:a6d3b5d0cc1fd456d43de3bf918d3caee"><td class="mdescLeft">&#160;</td><td class="mdescRight">computes the face neighbor points for additional computations for a specified direction.  <a href="#a6d3b5d0cc1fd456d43de3bf918d3caee">More...</a><br /></td></tr>
<tr class="separator:a6d3b5d0cc1fd456d43de3bf918d3caee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2229d77046b65bae889ffbbffc0380b4"><td class="memItemLeft" align="right" valign="top"><a id="a2229d77046b65bae889ffbbffc0380b4"></a>
EType&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classot_1_1Mesh.html#a2229d77046b65bae889ffbbffc0380b4">getElementType</a> (unsigned int eleID)</td></tr>
<tr class="memdesc:a2229d77046b65bae889ffbbffc0380b4"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns the type of the element. <br /></td></tr>
<tr class="separator:a2229d77046b65bae889ffbbffc0380b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Contains all the information needed to build neighbourhood information for the balanced octree based on treeSearch. </p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="ac84f51f52c587c2e4ad561c825cac86d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac84f51f52c587c2e4ad561c825cac86d">&#9670;&nbsp;</a></span>Mesh() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ot::Mesh::Mesh </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; <a class="el" href="classot_1_1TreeNode.html">ot::TreeNode</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>k_s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>pOrder</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>activeNpes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MPI_Comm&#160;</td>
          <td class="paramname"><em>comm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>pBlockSetup</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceot.html#a56125ff5472322284829fbf97534d6f0">SM_TYPE</a>&#160;</td>
          <td class="paramname"><em>smType</em> = <code>SM_TYPE::FDM</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>grainSz</em> = <code>DENDRO_DEFAULT_GRAIN_SZ</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>ld_tol</em> = <code>DENDRO_DEFAULT_LB_TOL</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>sf_k</em> = <code>DENDRO_DEFAULT_SF_K</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>parallel mesh constructor </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">in</td><td>complete sorted 2:1 balanced octree to generate mesh </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">k_s</td><td>how many neighbours to check on each direction (used =1) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pOrder</td><td>order of an element. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">commActive</td><td>MPI active communicator </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">comm</td><td>MPI communicator (global) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af6b6ae09c85674e2a330a70e2ef67200"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af6b6ae09c85674e2a330a70e2ef67200">&#9670;&nbsp;</a></span>Mesh() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ot::Mesh::Mesh </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; <a class="el" href="classot_1_1TreeNode.html">ot::TreeNode</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>k_s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>pOrder</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MPI_Comm&#160;</td>
          <td class="paramname"><em>comm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>pBlockSetup</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceot.html#a56125ff5472322284829fbf97534d6f0">SM_TYPE</a>&#160;</td>
          <td class="paramname"><em>smType</em> = <code>SM_TYPE::FDM</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>grainSz</em> = <code>DENDRO_DEFAULT_GRAIN_SZ</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>ld_tol</em> = <code>DENDRO_DEFAULT_LB_TOL</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>sf_k</em> = <code>DENDRO_DEFAULT_SF_K</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>parallel mesh constructor </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">in</td><td>complete sorted 2:1 balanced octree to generate mesh </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">k_s</td><td>how many neighbours to check on each direction (used =1) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pOrder</td><td>order of an element. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">comm</td><td>MPI communicator (global) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">grainSz</td><td>prefered grain sz. (this parameter is used to perform automatic comm expansion and shrinking) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ld_tol</td><td>load imbalance tolerance for comm expansion and shrinking </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">sf_k</td><td>splitter fix _k value. (Needed by SFC_partitioinng for large p&gt;=10,000) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="ab581c5ad4b179a08016433ff39623621"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab581c5ad4b179a08016433ff39623621">&#9670;&nbsp;</a></span>applyStencil()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , unsigned int length, unsigned int offsetCentered, unsigned int offsetBackward, unsigned int offsetForward&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void ot::Mesh::applyStencil </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structStencil.html">Stencil</a>&lt; T, length, offsetCentered &gt; &amp;&#160;</td>
          <td class="paramname"><em>centered</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structStencil.html">Stencil</a>&lt; T, length, offsetBackward &gt; &amp;&#160;</td>
          <td class="paramname"><em>backward</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structStencil.html">Stencil</a>&lt; T, length, offsetForward &gt; &amp;&#160;</td>
          <td class="paramname"><em>forward</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Apply a given stencil to for provided variable array. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">in</td><td>: vector that we need to apply the stencil on. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">centered</td><td><a class="el" href="structStencil.html">Stencil</a> that we need to apply on vector in, this is the centered stencil. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">backward</td><td>backward version of the centered stencil.(This is used for boundary elements. ) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">forward</td><td>foward version of the centered stencil. (This is used for boundary elements. ) </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">out</td><td>output vector that after applying the stencil. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a30e31c8e5add5344bfaa42aadf4d7ec3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a30e31c8e5add5344bfaa42aadf4d7ec3">&#9670;&nbsp;</a></span>child2ParentInjection()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void ot::Mesh::child2ParentInjection </td>
          <td>(</td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool *&#160;</td>
          <td class="paramname"><em>isHanging</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Performs child to parent injection. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">children</td><td>function values. (all the function values of children ordered according to the <a class="el" href="namespaceSFC.html">SFC</a> ordering) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">isHanging</td><td>array of boolean variables specifying each node is hanging ot not. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">injected</td><td>values back to parent. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a4126c5fc333598f60b04ab59a6205d64"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4126c5fc333598f60b04ab59a6205d64">&#9670;&nbsp;</a></span>child2ParentInterpolation()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void ot::Mesh::child2ParentInterpolation </td>
          <td>(</td>
          <td class="paramtype">const double *&#160;</td>
          <td class="paramname"><em>in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>cnum</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>dim</em> = <code>3</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>performs the child to parent contribution (only from a single child). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">in</td><td>child function values </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">cnum</td><td>morton ID of the current child. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">dim</td><td>dim of the interpolation. (dim=1 for edge interpolation , dim=2 for face interpolation, dim=3 for octant to child interpolation.) </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">out</td><td>interpolated values. (child to parent contribution) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a55788ff265719f60255af54e00ecb194"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a55788ff265719f60255af54e00ecb194">&#9670;&nbsp;</a></span>computeElementalContribution()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void ot::Mesh::computeElementalContribution </td>
          <td>(</td>
          <td class="paramtype">const T *&#160;</td>
          <td class="paramname"><em>in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>elementID</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>: Computes the contribution of elemental nodal values to the parent elements if it is hanging. Note: internal nodes for the elements cannnot be hagging. Only the face edge nodes are possible for hanging. </p>
<p>: input is the elemental nodal values. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">vec</td><td>child var vector (nPe) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">elementID</td><td>element ID of the current element (or child octant) </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">out</td><td>add the contributions to the current vector accordingly.</td></tr>
  </table>
  </dd>
</dl>
<p>Usage: This is needed when performing matrix-free matvec for FEM method. </p>

</div>
</div>
<a id="a6c574cbdf74920ea3d72e211104667fc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6c574cbdf74920ea3d72e211104667fc">&#9670;&nbsp;</a></span>cornerNodeIndex()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void ot::Mesh::cornerNodeIndex </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>elementID</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>mortonIndex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int &amp;&#160;</td>
          <td class="paramname"><em>index</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the index of m_uiE2NMapping (CG or DG) for a specified Edge. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">elementID</td><td>element ID of the edge, that the face belongs to . </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">mortonIndex</td><td>morton ID of the corner node in the cordinate change in the order of x y z. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">index</td><td>returns the indecies of the requested face. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a27f7b90e19c5d5e0dc2e8f2251547994"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a27f7b90e19c5d5e0dc2e8f2251547994">&#9670;&nbsp;</a></span>createUnZippedVector() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void ot::Mesh::createUnZippedVector </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>uvec</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>: creates (memory allocation) for the unzipped version of the vector. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname"></td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a3d06161d424da408bc13b081682fd258"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3d06161d424da408bc13b081682fd258">&#9670;&nbsp;</a></span>createUnZippedVector() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">T* ot::Mesh::createUnZippedVector </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>: creates (memory allocation) for the unzipped version of the vector. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname"></td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac67aa1cf985e121ef3adbf33bf5f5a92"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac67aa1cf985e121ef3adbf33bf5f5a92">&#9670;&nbsp;</a></span>createUnZippedVector() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void ot::Mesh::createUnZippedVector </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>uvec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T&#160;</td>
          <td class="paramname"><em>initValue</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>allocate memory for variable array based on the adaptive mesh. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">uvec</td><td>allocate memory for uvec (unzipped version) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">initValue</td><td>initialize the vector to the given value. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a249b4a2d1852bb354a0b325a0b0112e3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a249b4a2d1852bb354a0b325a0b0112e3">&#9670;&nbsp;</a></span>createUnZippedVector() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">T* ot::Mesh::createUnZippedVector </td>
          <td>(</td>
          <td class="paramtype">const T&#160;</td>
          <td class="paramname"><em>initValue</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>allocate memory for variable array based on the adaptive mesh. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">uvec</td><td>allocate memory for uvec (unzipped version) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">initValue</td><td>initialize the vector to the given value. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae747a8f9fd5af2f997574517370a2f09"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae747a8f9fd5af2f997574517370a2f09">&#9670;&nbsp;</a></span>createVector() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">T* ot::Mesh::createVector </td>
          <td>(</td>
          <td class="paramtype">const T&#160;</td>
          <td class="paramname"><em>initValue</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>allocate memory for variable array based on the adaptive mesh. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">initValue</td><td>initialize the vector to the given value. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab6fcb246647cec17192e6e9cd48569cc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab6fcb246647cec17192e6e9cd48569cc">&#9670;&nbsp;</a></span>createVector() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">T* ot::Mesh::createVector </td>
          <td>(</td>
          <td class="paramtype">std::function&lt; T(T, T, T)&gt;&#160;</td>
          <td class="paramname"><em>func</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>allocate memory for variable array based on the adaptive mesh. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">initValue</td><td>initialize the vector to the given value. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae27a7956c08a0511a5a4640b9c1bef81"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae27a7956c08a0511a5a4640b9c1bef81">&#9670;&nbsp;</a></span>createVector() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void ot::Mesh::createVector </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>vec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T&#160;</td>
          <td class="paramname"><em>initValue</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>allocate memory for variable array based on the adaptive mesh. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">vec</td><td>allocate memory for vec </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">initValue</td><td>initialize the vector to the given value. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af30ed1bc43510824f41a62591a3e0038"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af30ed1bc43510824f41a62591a3e0038">&#9670;&nbsp;</a></span>createVector() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void ot::Mesh::createVector </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>vec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::function&lt; T(T, T, T)&gt;&#160;</td>
          <td class="paramname"><em>func</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>create and initialize local elements based on a given function. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">vec</td><td>mesh varaible vector </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">func</td><td>function to initialize with. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a41cd588a236f94cb3f0a794ebb097cae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a41cd588a236f94cb3f0a794ebb097cae">&#9670;&nbsp;</a></span>edgeNodeIndex()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void ot::Mesh::edgeNodeIndex </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>elementID</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>face1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>face2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; unsigned int &gt; &amp;&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>isInternal</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the index of m_uiE2NMapping (CG or DG) for a specified Edge. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">elementID</td><td>element ID of the edge, that the face belongs to . </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">face1</td><td>: one of the face, that an edge belongs to </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">face2</td><td>second face that an edge belongs to . Hence the edge in cosideration will be intersection of the two faces, face1 and face2. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">isInternal</td><td>return only the internal nodes if true hence the index size would be ((m_uiElementOrder-1)*(m_uiElementOrder-1)) </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">index</td><td>returns the indecies of the requested face. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a4de13b90a7ff62e7c3ee13832d485a07"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4de13b90a7ff62e7c3ee13832d485a07">&#9670;&nbsp;</a></span>elementNodeIndex()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void ot::Mesh::elementNodeIndex </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>elementID</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; unsigned int &gt; &amp;&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>isInternal</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the all the internal node indices of an element. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">elementID</td><td>element ID of the edge, that the face belongs to . </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">isInternal</td><td>return only the internal nodes if true hence the index size would be ((m_uiElementOrder-1)*(m_uiElementOrder-1)) </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">index</td><td>returns the indecies of the requested face. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa5fed0ceb0f52016afd86537d60a09df"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa5fed0ceb0f52016afd86537d60a09df">&#9670;&nbsp;</a></span>faceNodesIndex()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void ot::Mesh::faceNodesIndex </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>elementID</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>face</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; unsigned int &gt; &amp;&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>isInternal</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the index of m_uiE2NMapping (CG or DG) for a specified face. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">elementID</td><td>element ID of the face, that the face belongs to . </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">face</td><td>: Face that you need the indexing, </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">isInternal</td><td>return only the internal nodes if true hence the index size would be ((m_uiElementOrder-1)*(m_uiElementOrder-1)) </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">index</td><td>returns the indecies of the requested face. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac32100681264cb448922827e2ed8512e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac32100681264cb448922827e2ed8512e">&#9670;&nbsp;</a></span>getE2NMapping()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const std::vector&lt;unsigned int&gt;&amp; ot::Mesh::getE2NMapping </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>returns const e2n mapping instance </p>

</div>
</div>
<a id="a9fe0d15495d3a0763b8abd59b79b61a7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9fe0d15495d3a0763b8abd59b79b61a7">&#9670;&nbsp;</a></span>getE2NMapping_DG()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const std::vector&lt;unsigned int&gt;&amp; ot::Mesh::getE2NMapping_DG </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>returns const e2n mapping instance (debuging purposes only) </p>

</div>
</div>
<a id="ad651aeb5e1cf64ae0dd5d85a19e25e46"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad651aeb5e1cf64ae0dd5d85a19e25e46">&#9670;&nbsp;</a></span>getElementalEdgeNeighbors()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ot::Mesh::getElementalEdgeNeighbors </td>
          <td>(</td>
          <td class="paramtype">const unsigned int&#160;</td>
          <td class="paramname"><em>eID</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned int&#160;</td>
          <td class="paramname"><em>dir</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int *&#160;</td>
          <td class="paramname"><em>lookup</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>returns the edge neighours in specidied direction. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">eID</td><td>Element ID. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">dir</td><td>direction of the edge. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">lookUp</td><td>result if the result is a same level or lower level than element ID. (only 4 neighbor) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a0961316035d62ce15eb23d2737d1c867"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0961316035d62ce15eb23d2737d1c867">&#9670;&nbsp;</a></span>getElementalFaceNeighbors()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ot::Mesh::getElementalFaceNeighbors </td>
          <td>(</td>
          <td class="paramtype">const unsigned int&#160;</td>
          <td class="paramname"><em>eID</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned int&#160;</td>
          <td class="paramname"><em>dir</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int *&#160;</td>
          <td class="paramname"><em>lookup</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>returns the face neighours in specidied direction. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">eID</td><td>Element ID. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">dir</td><td>direction of the face. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">lookUp</td><td>result if the result is a same level or lower level than element ID. (only 2 neighbor) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad7e40d1f1ec1f900f47a993a884d85db"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad7e40d1f1ec1f900f47a993a884d85db">&#9670;&nbsp;</a></span>getElementalVertexNeighbors()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ot::Mesh::getElementalVertexNeighbors </td>
          <td>(</td>
          <td class="paramtype">const unsigned int&#160;</td>
          <td class="paramname"><em>eID</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned int&#160;</td>
          <td class="paramname"><em>dir</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int *&#160;</td>
          <td class="paramname"><em>lookup</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>returns the vertex neighours in specidied direction. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">eID</td><td>Element ID. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">dir</td><td>direction of the vertex. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">lookUp</td><td>result if the result is a same level or lower level than element ID. (only 8 neighbor) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a6f95392f47adaf1fe8f10d76217b972f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6f95392f47adaf1fe8f10d76217b972f">&#9670;&nbsp;</a></span>getElementCoordinates()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ot::Mesh::getElementCoordinates </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>eleID</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>coords</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>computes the elementCoordinates (based on the nodal placement) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">eleID</td><td>: element ID </td></tr>
    <tr><td class="paramdir"></td><td class="paramname"></td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aaef546805498f31c6ad9b77383fa14d5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaef546805498f31c6ad9b77383fa14d5">&#9670;&nbsp;</a></span>getElementNodalValues()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void ot::Mesh::getElementNodalValues </td>
          <td>(</td>
          <td class="paramtype">const T *&#160;</td>
          <td class="paramname"><em>vec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>nodalValues</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>elementID</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>: Returns the nodal values of a given element for a given variable vector. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">vec</td><td>variable vector that we want to get the nodal values. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">elementID</td><td>element ID that we need to get the nodal values. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">nodalValues</td><td>nodal values of the specified element ID </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a182c1dc2ed3594bbfb125675a4fb7163"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a182c1dc2ed3594bbfb125675a4fb7163">&#9670;&nbsp;</a></span>getElementQMat()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ot::Mesh::getElementQMat </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>currentId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&amp;&#160;</td>
          <td class="paramname"><em>qMat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>isAllocated</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>: Compute the elemental interpolation matrix. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">currentId</td><td>Element ID. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname"></td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a6d3b5d0cc1fd456d43de3bf918d3caee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6d3b5d0cc1fd456d43de3bf918d3caee">&#9670;&nbsp;</a></span>getFaceNeighborValues()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">int ot::Mesh::getFaceNeighborValues </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>eleID</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T *&#160;</td>
          <td class="paramname"><em>in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>coords</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int *&#160;</td>
          <td class="paramname"><em>neighID</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>face</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">NeighbourLevel &amp;&#160;</td>
          <td class="paramname"><em>level</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>computes the face neighbor points for additional computations for a specified direction. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">eleID</td><td>element ID </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">in</td><td>inpute vector </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">out</td><td>output vector values are in the order of the x,y,z size : 4*NodesPerElement </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">coords</td><td>get the corresponding coordinates size: 4*NodesPerElement*m_uiDim; </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">neighID</td><td>face neighbor octant IDs, </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">face</td><td>face direction in {OCT_DIR_LEFT,OCT_IDR_RIGHT,OCT_DIR_DOWN, OCT_DIR_UP,OCT_DIR_BACK,OCT_DIR_FRONT} </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">level</td><td>the level of the neighbour octant with respect to the current octant. returns the number of face neighbours 1/4 for 3D. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a0a92b2be52e5928545ff2ab9e89432d4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0a92b2be52e5928545ff2ab9e89432d4">&#9670;&nbsp;</a></span>getNumLocalMeshElements()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int ot::Mesh::getNumLocalMeshElements </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns the number of local elements in the grid. (local to the current considering processor) </p>

</div>
</div>
<a id="a966ccc67ddc5e0b710db1928af7808ea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a966ccc67ddc5e0b710db1928af7808ea">&#9670;&nbsp;</a></span>getNumPreGhostElements()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int ot::Mesh::getNumPreGhostElements </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns the number of pre-ghost elements </p>

</div>
</div>
<a id="a8f2a75446405e404398ea8ff99102ff5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8f2a75446405e404398ea8ff99102ff5">&#9670;&nbsp;</a></span>getUnzipElementalNodalValues()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void ot::Mesh::getUnzipElementalNodalValues </td>
          <td>(</td>
          <td class="paramtype">const T *&#160;</td>
          <td class="paramname"><em>uzipVec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>blkID</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>ele</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>isPadded</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the elemental nodal values using unzip representation of the array. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>type of the vector. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">uzipVec</td><td>: unzip vector </td></tr>
    <tr><td class="paramname">blkID</td><td>: block ID the element belongs to </td></tr>
    <tr><td class="paramname">ele</td><td>: element ID of the block </td></tr>
    <tr><td class="paramname">out</td><td>: output values. (allocated with corresponding padding width) </td></tr>
    <tr><td class="paramname">isPadded</td><td>: true if the we need the elemental values with padding. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae7bf4daff7f8f951836236c1138b9cc7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae7bf4daff7f8f951836236c1138b9cc7">&#9670;&nbsp;</a></span>ghostExchangeRecvSync()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void ot::Mesh::ghostExchangeRecvSync </td>
          <td>(</td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>vec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>recvNodeBuffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MPI_Request *&#160;</td>
          <td class="paramname"><em>recv_reqs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MPI_Status *&#160;</td>
          <td class="paramname"><em>recv_sts</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Perform the wait on the recv requests. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">vec</td><td>adaptive mesh vector containing the values. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">recv_reqs</td><td>m_uiRecvProcList.size() recv request </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">recv_sts</td><td>m_uiRecvProcList.size() recv status </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af42b22f6abbedd20a695cb73bab7f3cb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af42b22f6abbedd20a695cb73bab7f3cb">&#9670;&nbsp;</a></span>ghostExchangeSendSync()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void ot::Mesh::ghostExchangeSendSync </td>
          <td>(</td>
          <td class="paramtype">MPI_Request *&#160;</td>
          <td class="paramname"><em>send_reqs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MPI_Status *&#160;</td>
          <td class="paramname"><em>send_sts</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Perform the wait on the recv requests. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">vec</td><td>adaptive mesh vector containing the values. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">send_reqs</td><td>m_uiSendProcList.size() send request </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">send_sts</td><td>m_uiSendProcList.size() send status </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a6699c141d1b3be3ab04cde54b3f5bf09"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6699c141d1b3be3ab04cde54b3f5bf09">&#9670;&nbsp;</a></span>ghostExchangeStart()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void ot::Mesh::ghostExchangeStart </td>
          <td>(</td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>vec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>sendNodeBuffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>recvNodeBuffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MPI_Request *&#160;</td>
          <td class="paramname"><em>send_reqs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MPI_Request *&#160;</td>
          <td class="paramname"><em>recv_reqs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Perform the ghost asynchronous send for the vector vec Note: this is a non-blocking asynchronous communication. User is resposible to call the (synchronous call such as MPI_WaitAll) when overlapping the communication and computation. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">vec</td><td>adaptive mesh vector contaiting the values. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a1dcdbec00948fa92004b9861fe45286d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1dcdbec00948fa92004b9861fe45286d">&#9670;&nbsp;</a></span>interGridTransfer() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void ot::Mesh::interGridTransfer </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>vec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classot_1_1Mesh.html">ot::Mesh</a> *&#160;</td>
          <td class="paramname"><em>pMesh</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>transfer a variable vector form old grid to new grid. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">vec</td><td>variable vector needs to be transfered. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">vec</td><td>transfered varaible vector </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pMesh</td><td><a class="el" href="classot_1_1Mesh.html">Mesh</a> that we need to transfer the old varaible. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a18778d695759db6c74ef839261f2ce3f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a18778d695759db6c74ef839261f2ce3f">&#9670;&nbsp;</a></span>interGridTransfer() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void ot::Mesh::interGridTransfer </td>
          <td>(</td>
          <td class="paramtype">T *&amp;&#160;</td>
          <td class="paramname"><em>vec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classot_1_1Mesh.html">ot::Mesh</a> *&#160;</td>
          <td class="paramname"><em>pMesh</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>transfer a variable vector form old grid to new grid. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">vec</td><td>variable vector needs to be transfered. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">vec</td><td>transfered varaible vector </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pMesh</td><td><a class="el" href="classot_1_1Mesh.html">Mesh</a> that we need to transfer the old varaible. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a5a314de88bd7759895f836445537c9e5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5a314de88bd7759895f836445537c9e5">&#9670;&nbsp;</a></span>interGridTransferUnzip()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void ot::Mesh::interGridTransferUnzip </td>
          <td>(</td>
          <td class="paramtype">T *&amp;&#160;</td>
          <td class="paramname"><em>unzip</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T *&amp;&#160;</td>
          <td class="paramname"><em>vec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classot_1_1Mesh.html">ot::Mesh</a> *&#160;</td>
          <td class="paramname"><em>pMesh</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>performs the intergrid transfer operation using the unzip representation. Compared to elemental intergrid transfer this uses information from neighbouring elements while the transfer occurs. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>: data type of the vectors </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">unzip</td><td>: unizp representation of the vectors. </td></tr>
    <tr><td class="paramname">vec</td><td>: zip representation of the transfered vectors. </td></tr>
    <tr><td class="paramname">pMesh</td><td>: new mesh. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a89590df87eb14c8ed68512ab2c5ab0ce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a89590df87eb14c8ed68512ab2c5ab0ce">&#9670;&nbsp;</a></span>isEdgeHanging()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ot::Mesh::isEdgeHanging </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>elementId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>edgeId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int &amp;&#160;</td>
          <td class="paramname"><em>cnum</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>: Returns true or false (bases on specified edge is hanging or not.)for a given element id , and edge id. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">elementId</td><td>element ID of the octant. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">edgeId</td><td>edge id </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="abbaaa964ec14c760646e1de13df51479"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abbaaa964ec14c760646e1de13df51479">&#9670;&nbsp;</a></span>isFaceHanging()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ot::Mesh::isFaceHanging </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>elementId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>faceId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int &amp;&#160;</td>
          <td class="paramname"><em>cnum</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>: Returns true or false (bases on specified edge is hanging or not.)for a given element id , and edge id. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">elementId</td><td>element ID of the octant. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">faceId</td><td>face id </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa3cdef1614570f1b22318e3fd8923468"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa3cdef1614570f1b22318e3fd8923468">&#9670;&nbsp;</a></span>isNodeHanging()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ot::Mesh::isNodeHanging </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>eleID</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>ix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>jy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>kz</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>: Returns true if the specified node (e,i,j,k) is hanging. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">eleID</td><td>element ID </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ix</td><td>i-index of the node. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">jy</td><td>j-index of the node. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">kz</td><td>k-index of the node. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a348335b97cb0491aec2168ede75aa2fe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a348335b97cb0491aec2168ede75aa2fe">&#9670;&nbsp;</a></span>isNodeLocal()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool ot::Mesh::isNodeLocal </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>eleID</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>ix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>jy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>kz</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>: Returns true if the specified node (e,i,j,k) is local. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">eleID</td><td>element ID </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ix</td><td>i-index of the node. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">jy</td><td>j-index of the node. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">kz</td><td>k-index of the node. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aeb87fe8ef3f3e3e3029588ec6e0d7d07"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeb87fe8ef3f3e3e3029588ec6e0d7d07">&#9670;&nbsp;</a></span>isReMesh()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool ot::Mesh::isReMesh </td>
          <td>(</td>
          <td class="paramtype">const T **&#160;</td>
          <td class="paramname"><em>vec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned int *&#160;</td>
          <td class="paramname"><em>varIds</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned int&#160;</td>
          <td class="paramname"><em>numVars</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>tol</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>amr_coarse_fac</em> = <code>DENDRO_AMR_COARSEN_FAC</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>: determine whether any refinement or coarsening need for a specified set of elements. (This uses zipped version of the varibles which needs to satiesfy some constraints. Not every element is eligible for refinemenet or coarsening). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">vec</td><td>sequence of varaibles to check </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">varIds</td><td>variable ids to check. (var ids to index the vec, vec[i] is a T* pointintg to one of the variable in vec. ) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">numVars</td><td>number of variables to check </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">tol</td><td>wavelet tolerance Returns true if specified variable violates the specified wavelet toerlance. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>: this method will flag every element in the mesh with OCT_NO_CHANGE, OCT_SPLIT, OCT_COARSE. </dd></dl>

</div>
</div>
<a id="af6a16defebca50f647744e066aef8612"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af6a16defebca50f647744e066aef8612">&#9670;&nbsp;</a></span>isReMeshUnzip()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool ot::Mesh::isReMeshUnzip </td>
          <td>(</td>
          <td class="paramtype">const T **&#160;</td>
          <td class="paramname"><em>unzippedVec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned int *&#160;</td>
          <td class="paramname"><em>varIds</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned int&#160;</td>
          <td class="paramname"><em>numVars</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::function&lt; double(double, double, double)&gt;&#160;</td>
          <td class="paramname"><em>wavelet_tol</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>amr_coarse_fac</em> = <code>DENDRO_AMR_COARSEN_FAC</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>coarsen_hx</em> = <code>DENDRO_REMESH_UNZIP_SCALE_FAC</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">vec</td><td>sequence of varaibles to check </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">varIds</td><td>variable ids to check. (var ids to index the vec, vec[i] is a T* pointintg to one of the variable in vec. ) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">numVars</td><td>number of variables to check </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">tol</td><td>wavelet tolerance Returns true if specified variable violates the specified wavelet toerlance. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>: this method will flag every element in the mesh with OCT_NO_CHANGE, OCT_SPLIT, OCT_COARSE. </dd></dl>

</div>
</div>
<a id="a698c8e504453e26d3fb7297fa9a1d432"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a698c8e504453e26d3fb7297fa9a1d432">&#9670;&nbsp;</a></span>parent2ChildInterpolation()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void ot::Mesh::parent2ChildInterpolation </td>
          <td>(</td>
          <td class="paramtype">const double *&#160;</td>
          <td class="paramname"><em>in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>cnum</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>dim</em> = <code>3</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Performs all parent to child interpolations for the m_uiEl_i element in order to apply the stencil. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">parent</td><td>function values </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">cnum</td><td>child number to interpolate. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">dim</td><td>dim of the interpolation. (dim=1 for edge interpolation , dim=2 for face interpolation, dim=3 for octant to child interpolation.) </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">out</td><td>interpolated values. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a51f2933622bf3219aed13a3506dd35dd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a51f2933622bf3219aed13a3506dd35dd">&#9670;&nbsp;</a></span>performGhostExchange() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void ot::Mesh::performGhostExchange </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>vec</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Perform the ghost exchange for the vector vec. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">vec</td><td>adaptive mesh vector contaiting the values. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af7487d05c4f0c6aa0e8ea7c99e10ad40"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af7487d05c4f0c6aa0e8ea7c99e10ad40">&#9670;&nbsp;</a></span>performGhostExchange() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void ot::Mesh::performGhostExchange </td>
          <td>(</td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>vec</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Perform the ghost exchange for the vector vec. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">vec</td><td>adaptive mesh vector contaiting the values. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a4025c805748265bf29a792dcddafb783"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4025c805748265bf29a792dcddafb783">&#9670;&nbsp;</a></span>ReMesh()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classot_1_1Mesh.html">ot::Mesh</a> * ot::Mesh::ReMesh </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>grainSz</em> = <code>DENDRO_DEFAULT_GRAIN_SZ</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>ld_tol</em> = <code>DENDRO_DEFAULT_LB_TOL</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>sfK</em> = <code>DENDRO_DEFAULT_SF_K</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int(*)(const <a class="el" href="classot_1_1TreeNode.html">ot::TreeNode</a> *)&#160;</td>
          <td class="paramname"><em>getWeight</em> = <code>NULL</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>: Remesh the mesh with the new computed elements. </p>
<dl class="section note"><dt>Note</dt><dd>assumes that refinedIDs and corasenIDs are sorted. (This is automatically done by the isRemesh Fucntion) </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">refinedIDs</td><td>element IDs need to be refined. (computed by isReMesh function) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">coarsenIDs</td><td>element IDs need to be coarsened. (computed by isReMesh function) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ld_tol</td><td>tolerance value used for flexible partitioning </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">sfK</td><td>spliiter fix parameter (need to specify larger value when run in super large scale) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">getWeight</td><td>function pointer which returns a uint weight values for an given octant </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a8abfe4be4d63f1f49ca02016c51e640e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8abfe4be4d63f1f49ca02016c51e640e">&#9670;&nbsp;</a></span>setOctreeRefineFlags()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ot::Mesh::setOctreeRefineFlags </td>
          <td>(</td>
          <td class="paramtype">unsigned int *&#160;</td>
          <td class="paramname"><em>flags</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>sz</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>set refinement flags for the octree. This is non const function </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">flags</td><td>indicating to refine/coarsen or no change </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">sz</td><td>size of the array flags, sz should be equivalent to number of local elements. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a9c30826c0278b278cfd20034ac531c8e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9c30826c0278b278cfd20034ac531c8e">&#9670;&nbsp;</a></span>unzip()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void ot::Mesh::unzip </td>
          <td>(</td>
          <td class="paramtype">const T *&#160;</td>
          <td class="paramname"><em>zippedVec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>unzippedVec</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates the decomposition of adaptive octree variables into blocklist variables that we computed. </p>
<dl class="section author"><dt>Author</dt><dd>Milinda Fernando </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">zippedVec</td><td>adaptive representation of the variable array. (created by createVec function) </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">unzippedVec</td><td>decomposed representation of the adaptive array. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>this routine assumes that for both arrays memory has been allocated. Routine is responsible only to fill up the unzipped entries. </dd></dl>

</div>
</div>
<a id="a45df9f6bb4dc2d73a675abaab087b076"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a45df9f6bb4dc2d73a675abaab087b076">&#9670;&nbsp;</a></span>unzip_async()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void ot::Mesh::unzip_async </td>
          <td>(</td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>zippedVec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>unzippedVec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MPI_Request *&#160;</td>
          <td class="paramname"><em>send_reqs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MPI_Request *&#160;</td>
          <td class="paramname"><em>recv_reqs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MPI_Status *&#160;</td>
          <td class="paramname"><em>send_sts</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MPI_Status *&#160;</td>
          <td class="paramname"><em>recv_sts</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>perform the unzip operation overlap with the communication. GHOST exchage done inside. User doesn't need to perofrm ghost exchange. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">zippedVec</td><td>adaptive representation of the variable array. (created by createVec function) </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">unzippedVec</td><td>decomposed representation of the adaptive array. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>this routine assumes that for both arrays memory has been allocated (No prior ghost exchange required). Routine is responsible only to fill up the unzipped entries. </dd></dl>

</div>
</div>
<a id="a1d89ba02e9b09ed5fe44d1c2c734daf5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1d89ba02e9b09ed5fe44d1c2c734daf5">&#9670;&nbsp;</a></span>vectorToVTK()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void ot::Mesh::vectorToVTK </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>vec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>fprefix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>pTime</em> = <code>0.0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>nCycle</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>write out function values to a vtk file. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">vec</td><td>variable vector that needs to be written as a vtk file. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">fprefix</td><td>prefix of the output vtk file name. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a6ef4ca39831332f297029d067c7ed471"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6ef4ca39831332f297029d067c7ed471">&#9670;&nbsp;</a></span>zip()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void ot::Mesh::zip </td>
          <td>(</td>
          <td class="paramtype">const T *&#160;</td>
          <td class="paramname"><em>unzippedVec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>zippedVec</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Performs the compression frrom regular block grid varable list to adaptive representation. </p>
<dl class="section author"><dt>Author</dt><dd>Milinda Fernando </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">unzippedVec</td><td>decomposed version of the adaptive array </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">compressed</td><td>version of the unzippedVec. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>include/<a class="el" href="mesh_8h_source.html">mesh.h</a></li>
<li>src/mesh.cpp</li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
