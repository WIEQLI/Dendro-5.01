<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Dendro: ot::DA Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="dendro.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Dendro
   &#160;<span id="projectnumber">5.01</span>
   </div>
   <div id="projectbrief">Dendro in Greek language means tree. The Dendro library is a large scale (262K cores on ORNL&#39;s Titan) distributed memory adaptive octree framework. The main goal of Dendro is to perform large scale multiphysics simulations efficeiently in mordern supercomputers. Dendro consists of efficient parallel data structures and algorithms to perform variational ( finite element) methods and finite difference mthods on 2:1 balanced arbitary adaptive octrees which enables the users to perform simulations raning from black holes (binary black hole mergers) to blood flow in human body, where applications ranging from relativity, astrophysics to biomedical engineering.</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespaceot.html">ot</a></li><li class="navelem"><a class="el" href="classot_1_1DA.html">DA</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="classot_1_1DA-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">ot::DA Class Reference</div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a23efd133fa851a9d24124fd3b49ac1f0"><td class="memItemLeft" align="right" valign="top"><a id="a23efd133fa851a9d24124fd3b49ac1f0"></a>
std::vector&lt; <a class="el" href="classot_1_1TreeNode.html">ot::TreeNode</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classot_1_1DA.html#a23efd133fa851a9d24124fd3b49ac1f0">getLocalOctants</a> ()</td></tr>
<tr class="memdesc:a23efd133fa851a9d24124fd3b49ac1f0"><td class="mdescLeft">&#160;</td><td class="mdescRight">: returns the vector containing only local elements <br /></td></tr>
<tr class="separator:a23efd133fa851a9d24124fd3b49ac1f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1e9ae594c33546e7b981541da2a7b485"><td class="memItemLeft" align="right" valign="top"><a id="a1e9ae594c33546e7b981541da2a7b485"></a>
const std::vector&lt; <a class="el" href="classot_1_1TreeNode.html">ot::TreeNode</a> &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classot_1_1DA.html#a1e9ae594c33546e7b981541da2a7b485">getBlocks</a> ()</td></tr>
<tr class="memdesc:a1e9ae594c33546e7b981541da2a7b485"><td class="mdescLeft">&#160;</td><td class="mdescRight">: get octree to block decomposition blocks <br /></td></tr>
<tr class="separator:a1e9ae594c33546e7b981541da2a7b485"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a07649a927d4c350188671998502c0391"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classot_1_1DA.html#a07649a927d4c350188671998502c0391">DA</a> (std::vector&lt; <a class="el" href="classot_1_1TreeNode.html">ot::TreeNode</a> &gt; &amp;balOct, MPI_Comm comm, unsigned int order, unsigned int grainSz=100, double sfc_tol=0.3, <a class="el" href="namespaceot.html#a56125ff5472322284829fbf97534d6f0">SM_TYPE</a> smType=SM_TYPE::FEM_CG)</td></tr>
<tr class="memdesc:a07649a927d4c350188671998502c0391"><td class="mdescLeft">&#160;</td><td class="mdescRight">: Constructor for the <a class="el" href="classot_1_1DA.html">DA</a> data structures  <a href="#a07649a927d4c350188671998502c0391">More...</a><br /></td></tr>
<tr class="separator:a07649a927d4c350188671998502c0391"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aca22d409ff768e7600c3e7681b47fac7"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classot_1_1DA.html#aca22d409ff768e7600c3e7681b47fac7">DA</a> (<a class="el" href="classot_1_1Mesh.html">ot::Mesh</a> *pMesh)</td></tr>
<tr class="memdesc:aca22d409ff768e7600c3e7681b47fac7"><td class="mdescLeft">&#160;</td><td class="mdescRight">: Create a <a class="el" href="classot_1_1DA.html">DA</a> from a specified mesh  <a href="#aca22d409ff768e7600c3e7681b47fac7">More...</a><br /></td></tr>
<tr class="separator:aca22d409ff768e7600c3e7681b47fac7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa703c2712d0e932c7036ce99a8f49db4"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:aa703c2712d0e932c7036ce99a8f49db4"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classot_1_1DA.html#aa703c2712d0e932c7036ce99a8f49db4">DA</a> (std::function&lt; void(T, T, T, T *)&gt;func, unsigned int dofSz, MPI_Comm comm, unsigned int order, double interp_tol, unsigned int grainSz=100, double sfc_tol=0.3, <a class="el" href="namespaceot.html#a56125ff5472322284829fbf97534d6f0">SM_TYPE</a> smType=SM_TYPE::FEM_CG)</td></tr>
<tr class="separator:aa703c2712d0e932c7036ce99a8f49db4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8d218d5e8907e2004d59e6aebf9bbdc1"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classot_1_1DA.html#a8d218d5e8907e2004d59e6aebf9bbdc1">DA</a> (const <a class="el" href="classPoint.html">Point</a> *pts, unsigned int numPts, <a class="el" href="classPoint.html">Point</a> pt_min, <a class="el" href="classPoint.html">Point</a> pt_max, MPI_Comm comm, unsigned int order, unsigned int grainSz=100, double sfc_tol=0.3, <a class="el" href="namespaceot.html#a56125ff5472322284829fbf97534d6f0">SM_TYPE</a> smType=SM_TYPE::FEM_CG)</td></tr>
<tr class="memdesc:a8d218d5e8907e2004d59e6aebf9bbdc1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct a new <a class="el" href="classot_1_1DA.html">DA</a> object from specified point set.  <a href="#a8d218d5e8907e2004d59e6aebf9bbdc1">More...</a><br /></td></tr>
<tr class="separator:a8d218d5e8907e2004d59e6aebf9bbdc1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a46df306739d5a5c409bad5aa77cb1b51"><td class="memItemLeft" align="right" valign="top"><a id="a46df306739d5a5c409bad5aa77cb1b51"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classot_1_1DA.html#a46df306739d5a5c409bad5aa77cb1b51">~DA</a> ()</td></tr>
<tr class="memdesc:a46df306739d5a5c409bad5aa77cb1b51"><td class="mdescLeft">&#160;</td><td class="mdescRight">deconstructor for the <a class="el" href="classot_1_1DA.html">DA</a> class. <br /></td></tr>
<tr class="separator:a46df306739d5a5c409bad5aa77cb1b51"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a66ff3df07ccc1a550d7aec7a37f1bd8a"><td class="memItemLeft" align="right" valign="top"><a id="a66ff3df07ccc1a550d7aec7a37f1bd8a"></a>
unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classot_1_1DA.html#a66ff3df07ccc1a550d7aec7a37f1bd8a">getLocalNodalSz</a> () const</td></tr>
<tr class="memdesc:a66ff3df07ccc1a550d7aec7a37f1bd8a"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns the local nodal size <br /></td></tr>
<tr class="separator:a66ff3df07ccc1a550d7aec7a37f1bd8a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a75468ac862aff209e2cfe16ae32a4c0c"><td class="memItemLeft" align="right" valign="top"><a id="a75468ac862aff209e2cfe16ae32a4c0c"></a>
unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classot_1_1DA.html#a75468ac862aff209e2cfe16ae32a4c0c">getPreNodalSz</a> () const</td></tr>
<tr class="memdesc:a75468ac862aff209e2cfe16ae32a4c0c"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns the pre ghost nodal size <br /></td></tr>
<tr class="separator:a75468ac862aff209e2cfe16ae32a4c0c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aedb4cbd7c662fb90d49503736b0a0162"><td class="memItemLeft" align="right" valign="top"><a id="aedb4cbd7c662fb90d49503736b0a0162"></a>
unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classot_1_1DA.html#aedb4cbd7c662fb90d49503736b0a0162">getPostNodalSz</a> () const</td></tr>
<tr class="memdesc:aedb4cbd7c662fb90d49503736b0a0162"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns the post nodal size <br /></td></tr>
<tr class="separator:aedb4cbd7c662fb90d49503736b0a0162"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeacedf870a7019a62cbfaa5653f37a45"><td class="memItemLeft" align="right" valign="top"><a id="aeacedf870a7019a62cbfaa5653f37a45"></a>
unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classot_1_1DA.html#aeacedf870a7019a62cbfaa5653f37a45">getTotalNodalSz</a> () const</td></tr>
<tr class="memdesc:aeacedf870a7019a62cbfaa5653f37a45"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns the total nodal size (this includes the ghosted region as well.) <br /></td></tr>
<tr class="separator:aeacedf870a7019a62cbfaa5653f37a45"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa4799247695049d85a2879403e5991e2"><td class="memItemLeft" align="right" valign="top"><a id="aa4799247695049d85a2879403e5991e2"></a>
unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classot_1_1DA.html#aa4799247695049d85a2879403e5991e2">getLocalElemSz</a> () const</td></tr>
<tr class="memdesc:aa4799247695049d85a2879403e5991e2"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns the local elemental size <br /></td></tr>
<tr class="separator:aa4799247695049d85a2879403e5991e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c2c34f1b8d752cd8431f90a47cbd19e"><td class="memItemLeft" align="right" valign="top"><a id="a7c2c34f1b8d752cd8431f90a47cbd19e"></a>
unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classot_1_1DA.html#a7c2c34f1b8d752cd8431f90a47cbd19e">getTotalElemSz</a> () const</td></tr>
<tr class="memdesc:a7c2c34f1b8d752cd8431f90a47cbd19e"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns the local elemental size (includes the ghost elements as well) <br /></td></tr>
<tr class="separator:a7c2c34f1b8d752cd8431f90a47cbd19e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3f0f3681903181680e4a33b9c3947161"><td class="memItemLeft" align="right" valign="top"><a id="a3f0f3681903181680e4a33b9c3947161"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classot_1_1DA.html#a3f0f3681903181680e4a33b9c3947161">isActive</a> () const</td></tr>
<tr class="memdesc:a3f0f3681903181680e4a33b9c3947161"><td class="mdescLeft">&#160;</td><td class="mdescRight">see if the current <a class="el" href="classot_1_1DA.html">DA</a> is active <br /></td></tr>
<tr class="separator:a3f0f3681903181680e4a33b9c3947161"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0f17cd2288655434727f6b096bd42978"><td class="memItemLeft" align="right" valign="top"><a id="a0f17cd2288655434727f6b096bd42978"></a>
unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classot_1_1DA.html#a0f17cd2288655434727f6b096bd42978">getNumNodesPerElement</a> () const</td></tr>
<tr class="memdesc:a0f17cd2288655434727f6b096bd42978"><td class="mdescLeft">&#160;</td><td class="mdescRight">get number of nodes per element <br /></td></tr>
<tr class="separator:a0f17cd2288655434727f6b096bd42978"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a077cd2470b9f51a12b02d162fc1981d0"><td class="memItemLeft" align="right" valign="top"><a id="a077cd2470b9f51a12b02d162fc1981d0"></a>
unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classot_1_1DA.html#a077cd2470b9f51a12b02d162fc1981d0">getElementOrder</a> () const</td></tr>
<tr class="memdesc:a077cd2470b9f51a12b02d162fc1981d0"><td class="mdescLeft">&#160;</td><td class="mdescRight">get element order <br /></td></tr>
<tr class="separator:a077cd2470b9f51a12b02d162fc1981d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2fb43c2ab7929deaa9422063f7c6c315"><td class="memItemLeft" align="right" valign="top"><a id="a2fb43c2ab7929deaa9422063f7c6c315"></a>
MPI_Comm&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classot_1_1DA.html#a2fb43c2ab7929deaa9422063f7c6c315">getGlobalComm</a> () const</td></tr>
<tr class="memdesc:a2fb43c2ab7929deaa9422063f7c6c315"><td class="mdescLeft">&#160;</td><td class="mdescRight">: returns the global MPI communicator <br /></td></tr>
<tr class="separator:a2fb43c2ab7929deaa9422063f7c6c315"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a99cfe9357d8123a6a9e35bdf8dd07d4c"><td class="memItemLeft" align="right" valign="top"><a id="a99cfe9357d8123a6a9e35bdf8dd07d4c"></a>
const std::vector&lt; DendroIntL &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classot_1_1DA.html#a99cfe9357d8123a6a9e35bdf8dd07d4c">getNodeLocalToGlobalMap</a> () const</td></tr>
<tr class="memdesc:a99cfe9357d8123a6a9e35bdf8dd07d4c"><td class="mdescLeft">&#160;</td><td class="mdescRight">: returns node local to node global map <br /></td></tr>
<tr class="separator:a99cfe9357d8123a6a9e35bdf8dd07d4c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a14e14ea83f32e1f19240915897ce78c1"><td class="memItemLeft" align="right" valign="top"><a id="a14e14ea83f32e1f19240915897ce78c1"></a>
const <a class="el" href="classot_1_1Mesh.html">ot::Mesh</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classot_1_1DA.html#a14e14ea83f32e1f19240915897ce78c1">getMesh</a> () const</td></tr>
<tr class="memdesc:a14e14ea83f32e1f19240915897ce78c1"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns the mesh <br /></td></tr>
<tr class="separator:a14e14ea83f32e1f19240915897ce78c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4e90df09b9457a03de7d1a22f13def1a"><td class="memItemLeft" align="right" valign="top"><a id="a4e90df09b9457a03de7d1a22f13def1a"></a>
const std::vector&lt; unsigned int &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classot_1_1DA.html#a4e90df09b9457a03de7d1a22f13def1a">getOctFlags</a> () const</td></tr>
<tr class="memdesc:a4e90df09b9457a03de7d1a22f13def1a"><td class="mdescLeft">&#160;</td><td class="mdescRight">: Returns octDA flags <br /></td></tr>
<tr class="separator:a4e90df09b9457a03de7d1a22f13def1a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac2ee2bc4af80a18ad82b1f0f7982e5fa"><td class="memItemLeft" align="right" valign="top"><a id="ac2ee2bc4af80a18ad82b1f0f7982e5fa"></a>
MPI_Comm&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classot_1_1DA.html#ac2ee2bc4af80a18ad82b1f0f7982e5fa">getCommActive</a> () const</td></tr>
<tr class="memdesc:ac2ee2bc4af80a18ad82b1f0f7982e5fa"><td class="mdescLeft">&#160;</td><td class="mdescRight">: returns the active MPI sub com of the global communicator <br /></td></tr>
<tr class="separator:ac2ee2bc4af80a18ad82b1f0f7982e5fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3231093342a0ff54860a2158589ba827"><td class="memItemLeft" align="right" valign="top"><a id="a3231093342a0ff54860a2158589ba827"></a>
unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classot_1_1DA.html#a3231093342a0ff54860a2158589ba827">getNpesAll</a> () const</td></tr>
<tr class="memdesc:a3231093342a0ff54860a2158589ba827"><td class="mdescLeft">&#160;</td><td class="mdescRight">: global mpi com. size <br /></td></tr>
<tr class="separator:a3231093342a0ff54860a2158589ba827"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa01496aeb23af8473165a872281de5c4"><td class="memItemLeft" align="right" valign="top"><a id="aa01496aeb23af8473165a872281de5c4"></a>
unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classot_1_1DA.html#aa01496aeb23af8473165a872281de5c4">getNpesActive</a> () const</td></tr>
<tr class="memdesc:aa01496aeb23af8473165a872281de5c4"><td class="mdescLeft">&#160;</td><td class="mdescRight">: number of processors active <br /></td></tr>
<tr class="separator:aa01496aeb23af8473165a872281de5c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e50a8a8f60c83c165ee4a386103f55b"><td class="memItemLeft" align="right" valign="top"><a id="a6e50a8a8f60c83c165ee4a386103f55b"></a>
unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classot_1_1DA.html#a6e50a8a8f60c83c165ee4a386103f55b">getRankAll</a> () const</td></tr>
<tr class="memdesc:a6e50a8a8f60c83c165ee4a386103f55b"><td class="mdescLeft">&#160;</td><td class="mdescRight">: rank with respect to the global comm. <br /></td></tr>
<tr class="separator:a6e50a8a8f60c83c165ee4a386103f55b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a94f37debaec462c375306e72e40358da"><td class="memItemLeft" align="right" valign="top"><a id="a94f37debaec462c375306e72e40358da"></a>
unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classot_1_1DA.html#a94f37debaec462c375306e72e40358da">getRankActive</a> () const</td></tr>
<tr class="memdesc:a94f37debaec462c375306e72e40358da"><td class="mdescLeft">&#160;</td><td class="mdescRight">: rank w.r.t active comm. <br /></td></tr>
<tr class="separator:a94f37debaec462c375306e72e40358da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a486603cbf63863eb78741fedb2fe1dc8"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classot_1_1DA.html#a486603cbf63863eb78741fedb2fe1dc8">isBoundaryOctant</a> (unsigned int eleID) const</td></tr>
<tr class="memdesc:a486603cbf63863eb78741fedb2fe1dc8"><td class="mdescLeft">&#160;</td><td class="mdescRight">: returns true if specified eleID is a boundary element false if the eleID is local and not a boundary element.  <a href="#a486603cbf63863eb78741fedb2fe1dc8">More...</a><br /></td></tr>
<tr class="separator:a486603cbf63863eb78741fedb2fe1dc8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa80c00e420dbe2a77afd9eb706ee3446"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classot_1_1DA.html#aa80c00e420dbe2a77afd9eb706ee3446">getElementalCoords</a> (unsigned int eleID, double *coords) const</td></tr>
<tr class="memdesc:aa80c00e420dbe2a77afd9eb706ee3446"><td class="mdescLeft">&#160;</td><td class="mdescRight">computes the elementCoordinates (based on the nodal placement)  <a href="#aa80c00e420dbe2a77afd9eb706ee3446">More...</a><br /></td></tr>
<tr class="separator:aa80c00e420dbe2a77afd9eb706ee3446"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a788a49d1a0b8d579064ab28b89b79256"><td class="memItemLeft" align="right" valign="top"><a id="a788a49d1a0b8d579064ab28b89b79256"></a>
const <a class="el" href="classRefElement.html">RefElement</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classot_1_1DA.html#a788a49d1a0b8d579064ab28b89b79256">getReferenceElement</a> () const</td></tr>
<tr class="memdesc:a788a49d1a0b8d579064ab28b89b79256"><td class="mdescLeft">&#160;</td><td class="mdescRight">get a constant pointer for the reference element <br /></td></tr>
<tr class="separator:a788a49d1a0b8d579064ab28b89b79256"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a541a275753daa15dd356a45c236ab7de"><td class="memItemLeft" align="right" valign="top"><a id="a541a275753daa15dd356a45c236ab7de"></a>
unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classot_1_1DA.html#a541a275753daa15dd356a45c236ab7de">getElementSize</a> () const</td></tr>
<tr class="memdesc:a541a275753daa15dd356a45c236ab7de"><td class="mdescLeft">&#160;</td><td class="mdescRight">: get the number of local elements. <br /></td></tr>
<tr class="separator:a541a275753daa15dd356a45c236ab7de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0258f9f485ac9e2d9f4eba68fab9baf0"><td class="memItemLeft" align="right" valign="top"><a id="a0258f9f485ac9e2d9f4eba68fab9baf0"></a>
unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classot_1_1DA.html#a0258f9f485ac9e2d9f4eba68fab9baf0">getPreGhostElementSize</a> () const</td></tr>
<tr class="memdesc:a0258f9f485ac9e2d9f4eba68fab9baf0"><td class="mdescLeft">&#160;</td><td class="mdescRight">: get the number of pre-ghost element size <br /></td></tr>
<tr class="separator:a0258f9f485ac9e2d9f4eba68fab9baf0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af82449d96e59f8d4d2b5ae51de661fb0"><td class="memItemLeft" align="right" valign="top"><a id="af82449d96e59f8d4d2b5ae51de661fb0"></a>
unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classot_1_1DA.html#af82449d96e59f8d4d2b5ae51de661fb0">getPostGhostElementSize</a> () const</td></tr>
<tr class="memdesc:af82449d96e59f8d4d2b5ae51de661fb0"><td class="mdescLeft">&#160;</td><td class="mdescRight">: get the number of post-ghost element size <br /></td></tr>
<tr class="separator:af82449d96e59f8d4d2b5ae51de661fb0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad6756dcc788de5eabdc805a9dd5f456b"><td class="memItemLeft" align="right" valign="top"><a id="ad6756dcc788de5eabdc805a9dd5f456b"></a>
unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classot_1_1DA.html#ad6756dcc788de5eabdc805a9dd5f456b">getPreAndPostGhostNodeSize</a> () const</td></tr>
<tr class="memdesc:ad6756dcc788de5eabdc805a9dd5f456b"><td class="mdescLeft">&#160;</td><td class="mdescRight">: get the number of pre and post ghost elements <br /></td></tr>
<tr class="separator:ad6756dcc788de5eabdc805a9dd5f456b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaae06c7fff4654d6b8b0c2ffb1e50cbb"><td class="memItemLeft" align="right" valign="top"><a id="aaae06c7fff4654d6b8b0c2ffb1e50cbb"></a>
unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classot_1_1DA.html#aaae06c7fff4654d6b8b0c2ffb1e50cbb">getNumLayer1GhostEleSz</a> () const</td></tr>
<tr class="memdesc:aaae06c7fff4654d6b8b0c2ffb1e50cbb"><td class="mdescLeft">&#160;</td><td class="mdescRight">number of layer 1 ghost elements. <br /></td></tr>
<tr class="separator:aaae06c7fff4654d6b8b0c2ffb1e50cbb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a37bb9fea757d1b8ae05225fc4735c3b5"><td class="memItemLeft" align="right" valign="top"><a id="a37bb9fea757d1b8ae05225fc4735c3b5"></a>
unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classot_1_1DA.html#a37bb9fea757d1b8ae05225fc4735c3b5">getGhostedElementSize</a> () const</td></tr>
<tr class="memdesc:a37bb9fea757d1b8ae05225fc4735c3b5"><td class="mdescLeft">&#160;</td><td class="mdescRight">: get the number of pre and post ghost elements <br /></td></tr>
<tr class="separator:a37bb9fea757d1b8ae05225fc4735c3b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa6a8664df93b972c81ac078d226d32aa"><td class="memItemLeft" align="right" valign="top"><a id="aa6a8664df93b972c81ac078d226d32aa"></a>
unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classot_1_1DA.html#aa6a8664df93b972c81ac078d226d32aa">getMaxDepth</a> () const</td></tr>
<tr class="memdesc:aa6a8664df93b972c81ac078d226d32aa"><td class="mdescLeft">&#160;</td><td class="mdescRight">: get the max depth of the octree <br /></td></tr>
<tr class="separator:aa6a8664df93b972c81ac078d226d32aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a61ac3ea1741e24246537a0d249fbe9e0"><td class="memItemLeft" align="right" valign="top"><a id="a61ac3ea1741e24246537a0d249fbe9e0"></a>
unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classot_1_1DA.html#a61ac3ea1741e24246537a0d249fbe9e0">getDimension</a> () const</td></tr>
<tr class="memdesc:a61ac3ea1741e24246537a0d249fbe9e0"><td class="mdescLeft">&#160;</td><td class="mdescRight">: get the dimensionality of the octree <br /></td></tr>
<tr class="separator:a61ac3ea1741e24246537a0d249fbe9e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae9fb4c4ab568b16ab5009f35da3d9917"><td class="memItemLeft" align="right" valign="top"><a id="ae9fb4c4ab568b16ab5009f35da3d9917"></a>
<a class="el" href="classot_1_1TreeNode.html">ot::TreeNode</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classot_1_1DA.html#ae9fb4c4ab568b16ab5009f35da3d9917">getMinTreeNode</a> () const</td></tr>
<tr class="memdesc:ae9fb4c4ab568b16ab5009f35da3d9917"><td class="mdescLeft">&#160;</td><td class="mdescRight">get min local node (nodal) <br /></td></tr>
<tr class="separator:ae9fb4c4ab568b16ab5009f35da3d9917"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adcc8fafe4a52904c5e7838cc762fdff2"><td class="memItemLeft" align="right" valign="top"><a id="adcc8fafe4a52904c5e7838cc762fdff2"></a>
<a class="el" href="classot_1_1TreeNode.html">ot::TreeNode</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classot_1_1DA.html#adcc8fafe4a52904c5e7838cc762fdff2">getMaxTreeNode</a> () const</td></tr>
<tr class="memdesc:adcc8fafe4a52904c5e7838cc762fdff2"><td class="mdescLeft">&#160;</td><td class="mdescRight">get max localnode (nodal) <br /></td></tr>
<tr class="separator:adcc8fafe4a52904c5e7838cc762fdff2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aab4e55c9b42b698d80b2da12f639bb3d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classot_1_1DA.html#aab4e55c9b42b698d80b2da12f639bb3d">computeTreeNodeOwnerProc</a> (const <a class="el" href="classot_1_1TreeNode.html">ot::TreeNode</a> *pNodes, unsigned int n, int *ownerranks)</td></tr>
<tr class="separator:aab4e55c9b42b698d80b2da12f639bb3d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abfd158a55b265275afa09175aaa428ad"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:abfd158a55b265275afa09175aaa428ad"><td class="memTemplItemLeft" align="right" valign="top">int&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classot_1_1DA.html#abfd158a55b265275afa09175aaa428ad">createVector</a> (T *&amp;local, bool isElemental=false, bool isGhosted=false, unsigned int dof=1) const</td></tr>
<tr class="memdesc:abfd158a55b265275afa09175aaa428ad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a ODA vector.  <a href="#abfd158a55b265275afa09175aaa428ad">More...</a><br /></td></tr>
<tr class="separator:abfd158a55b265275afa09175aaa428ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac78a13f67d93b4c277b25471e0a8412d"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ac78a13f67d93b4c277b25471e0a8412d"><td class="memTemplItemLeft" align="right" valign="top">int&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classot_1_1DA.html#ac78a13f67d93b4c277b25471e0a8412d">createVector</a> (std::vector&lt; T &gt; &amp;local, bool isElemental=false, bool isGhosted=false, unsigned int dof=1) const</td></tr>
<tr class="memdesc:ac78a13f67d93b4c277b25471e0a8412d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a ODA vector std::vector&lt;T&gt;  <a href="#ac78a13f67d93b4c277b25471e0a8412d">More...</a><br /></td></tr>
<tr class="separator:ac78a13f67d93b4c277b25471e0a8412d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afac164d36b839c9c4e6bd76065b87ad9"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:afac164d36b839c9c4e6bd76065b87ad9"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classot_1_1DA.html#afac164d36b839c9c4e6bd76065b87ad9">destroyVector</a> (T *&amp;local) const</td></tr>
<tr class="memdesc:afac164d36b839c9c4e6bd76065b87ad9"><td class="mdescLeft">&#160;</td><td class="mdescRight">deallocates the memory allocated for a vector  <a href="#afac164d36b839c9c4e6bd76065b87ad9">More...</a><br /></td></tr>
<tr class="separator:afac164d36b839c9c4e6bd76065b87ad9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae9922437e7dd890210e0d02c21666ce9"><td class="memTemplParams" colspan="2"><a id="ae9922437e7dd890210e0d02c21666ce9"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:ae9922437e7dd890210e0d02c21666ce9"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>destroyVector</b> (std::vector&lt; T &gt; &amp;local) const</td></tr>
<tr class="separator:ae9922437e7dd890210e0d02c21666ce9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:affb4c0145eebc9ee93804672661cdf7e"><td class="memTemplParams" colspan="2"><a id="affb4c0145eebc9ee93804672661cdf7e"></a>
template&lt;ot::DA_FLAGS::LoopType type&gt; </td></tr>
<tr class="memitem:affb4c0145eebc9ee93804672661cdf7e"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classot_1_1DA.html#affb4c0145eebc9ee93804672661cdf7e">init</a> ()</td></tr>
<tr class="memdesc:affb4c0145eebc9ee93804672661cdf7e"><td class="mdescLeft">&#160;</td><td class="mdescRight">initialize the loop counters. <br /></td></tr>
<tr class="separator:affb4c0145eebc9ee93804672661cdf7e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af2a33ded65ad8dfa076683bfb7fe750f"><td class="memItemLeft" align="right" valign="top"><a id="af2a33ded65ad8dfa076683bfb7fe750f"></a>
unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classot_1_1DA.html#af2a33ded65ad8dfa076683bfb7fe750f">curr</a> ()</td></tr>
<tr class="memdesc:af2a33ded65ad8dfa076683bfb7fe750f"><td class="mdescLeft">&#160;</td><td class="mdescRight">get the current elmenent in the iteration <br /></td></tr>
<tr class="separator:af2a33ded65ad8dfa076683bfb7fe750f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1260937e91e8f2461b3fa06d655e5882"><td class="memTemplParams" colspan="2"><a id="a1260937e91e8f2461b3fa06d655e5882"></a>
template&lt;ot::DA_FLAGS::LoopType type&gt; </td></tr>
<tr class="memitem:a1260937e91e8f2461b3fa06d655e5882"><td class="memTemplItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classot_1_1DA.html#a1260937e91e8f2461b3fa06d655e5882">end</a> ()</td></tr>
<tr class="memdesc:a1260937e91e8f2461b3fa06d655e5882"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns if the current element has reached end or not. <br /></td></tr>
<tr class="separator:a1260937e91e8f2461b3fa06d655e5882"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a21dd53de5553958375e06c76a714d899"><td class="memTemplParams" colspan="2"><a id="a21dd53de5553958375e06c76a714d899"></a>
template&lt;ot::DA_FLAGS::LoopType type&gt; </td></tr>
<tr class="memitem:a21dd53de5553958375e06c76a714d899"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classot_1_1DA.html#a21dd53de5553958375e06c76a714d899">next</a> ()</td></tr>
<tr class="memdesc:a21dd53de5553958375e06c76a714d899"><td class="mdescLeft">&#160;</td><td class="mdescRight">: increment it to the next element. <br /></td></tr>
<tr class="separator:a21dd53de5553958375e06c76a714d899"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0e66f632cacb28b747ad7dfba0980a66"><td class="memTemplParams" colspan="2"><a id="a0e66f632cacb28b747ad7dfba0980a66"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a0e66f632cacb28b747ad7dfba0980a66"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classot_1_1DA.html#a0e66f632cacb28b747ad7dfba0980a66">readFromGhostBegin</a> (T *vec, unsigned int dof=1)</td></tr>
<tr class="memdesc:a0e66f632cacb28b747ad7dfba0980a66"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initiate the ghost nodal value exchange. <br /></td></tr>
<tr class="separator:a0e66f632cacb28b747ad7dfba0980a66"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc25056989ba5828a3a63d4706b6804b"><td class="memTemplParams" colspan="2"><a id="abc25056989ba5828a3a63d4706b6804b"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:abc25056989ba5828a3a63d4706b6804b"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classot_1_1DA.html#abc25056989ba5828a3a63d4706b6804b">readFromGhostEnd</a> (T *vec, unsigned int dof=1)</td></tr>
<tr class="memdesc:abc25056989ba5828a3a63d4706b6804b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sync the ghost element exchange. <br /></td></tr>
<tr class="separator:abc25056989ba5828a3a63d4706b6804b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3efd028248fab5e9cd873ade53c48011"><td class="memTemplParams" colspan="2"><a id="a3efd028248fab5e9cd873ade53c48011"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a3efd028248fab5e9cd873ade53c48011"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classot_1_1DA.html#a3efd028248fab5e9cd873ade53c48011">writeToGhostsBegin</a> (T *vec, unsigned int dof=1)</td></tr>
<tr class="memdesc:a3efd028248fab5e9cd873ade53c48011"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initiate accumilation across ghost elements. <br /></td></tr>
<tr class="separator:a3efd028248fab5e9cd873ade53c48011"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6f23c152d4cb25affa9b2cb2bf5214e5"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a6f23c152d4cb25affa9b2cb2bf5214e5"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classot_1_1DA.html#a6f23c152d4cb25affa9b2cb2bf5214e5">writeToGhostsEnd</a> (T *vec, DA_FLAGS::WriteMode mode, unsigned int dof=1)</td></tr>
<tr class="memdesc:a6f23c152d4cb25affa9b2cb2bf5214e5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sync accumilation across ghost elements.  <a href="#a6f23c152d4cb25affa9b2cb2bf5214e5">More...</a><br /></td></tr>
<tr class="separator:a6f23c152d4cb25affa9b2cb2bf5214e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab2482a490d4879c51bbf73940f9b6235"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ab2482a490d4879c51bbf73940f9b6235"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classot_1_1DA.html#ab2482a490d4879c51bbf73940f9b6235">nodalVecToGhostedNodal</a> (const T *in, T *&amp;out, bool isAllocated=false, unsigned int dof=1) const</td></tr>
<tr class="memdesc:ab2482a490d4879c51bbf73940f9b6235"><td class="mdescLeft">&#160;</td><td class="mdescRight">convert nodal local vector with ghosted buffer regions.  <a href="#ab2482a490d4879c51bbf73940f9b6235">More...</a><br /></td></tr>
<tr class="separator:ab2482a490d4879c51bbf73940f9b6235"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a672aa204e474e22b48a127018dc967fa"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a672aa204e474e22b48a127018dc967fa"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classot_1_1DA.html#a672aa204e474e22b48a127018dc967fa">ghostedNodalToNodalVec</a> (const T *gVec, T *&amp;local, bool isAllocated=false, unsigned int dof=1) const</td></tr>
<tr class="memdesc:a672aa204e474e22b48a127018dc967fa"><td class="mdescLeft">&#160;</td><td class="mdescRight">convert ghosted nodal vector to local vector (without ghosting)  <a href="#a672aa204e474e22b48a127018dc967fa">More...</a><br /></td></tr>
<tr class="separator:a672aa204e474e22b48a127018dc967fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a95ac73b523469953ff82fe0ae431bf2b"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a95ac73b523469953ff82fe0ae431bf2b"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classot_1_1DA.html#a95ac73b523469953ff82fe0ae431bf2b">getElementNodalValues</a> (const T *in, T *eleVecOut, unsigned int eleID, unsigned int dof=1) const</td></tr>
<tr class="memdesc:a95ac73b523469953ff82fe0ae431bf2b"><td class="mdescLeft">&#160;</td><td class="mdescRight">computes the element nodal values using interpolation if needed.  <a href="#a95ac73b523469953ff82fe0ae431bf2b">More...</a><br /></td></tr>
<tr class="separator:a95ac73b523469953ff82fe0ae431bf2b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a169e4838e1504e933f14eca6b9079281"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a169e4838e1504e933f14eca6b9079281"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classot_1_1DA.html#a169e4838e1504e933f14eca6b9079281">eleVecToVecAccumilation</a> (T *out, const T *eleVecIn, unsigned int eleID, unsigned int dof=1) const</td></tr>
<tr class="memdesc:a169e4838e1504e933f14eca6b9079281"><td class="mdescLeft">&#160;</td><td class="mdescRight">computes the elemental vec to global vec accumilation  <a href="#a169e4838e1504e933f14eca6b9079281">More...</a><br /></td></tr>
<tr class="separator:a169e4838e1504e933f14eca6b9079281"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa0cecbca04037fab197f0282290d996d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classot_1_1DA.html#aa0cecbca04037fab197f0282290d996d">getOctreeBoundaryNodeIndices</a> (std::vector&lt; unsigned int &gt; &amp;bdyIndex, std::vector&lt; double &gt; &amp;coords, bool isGhosted=false)</td></tr>
<tr class="memdesc:aa0cecbca04037fab197f0282290d996d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the octree writable boundary nodes.  <a href="#aa0cecbca04037fab197f0282290d996d">More...</a><br /></td></tr>
<tr class="separator:aa0cecbca04037fab197f0282290d996d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aff20b56a9d1873815cf164d3da4d1b3b"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classot_1_1DA.html#aff20b56a9d1873815cf164d3da4d1b3b">getNodeIndices</a> (DendroIntL *nodeIdx, unsigned int ele, bool isGhosted) const</td></tr>
<tr class="memdesc:aff20b56a9d1873815cf164d3da4d1b3b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the local indices to the nodes of the current element.  <a href="#aff20b56a9d1873815cf164d3da4d1b3b">More...</a><br /></td></tr>
<tr class="separator:aff20b56a9d1873815cf164d3da4d1b3b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a70079babcf7ada81fa1a4a0831a5f221"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classot_1_1DA.html#a70079babcf7ada81fa1a4a0831a5f221">getGlobalNodeIndices</a> (DendroIntL *nodeIdx, unsigned int ele) const</td></tr>
<tr class="memdesc:a70079babcf7ada81fa1a4a0831a5f221"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the global node indices of a given element,.  <a href="#a70079babcf7ada81fa1a4a0831a5f221">More...</a><br /></td></tr>
<tr class="separator:a70079babcf7ada81fa1a4a0831a5f221"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0bbac21100bc43baeeea130c94cd019a"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a0bbac21100bc43baeeea130c94cd019a"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classot_1_1DA.html#a0bbac21100bc43baeeea130c94cd019a">setVectorByFunction</a> (T *local, std::function&lt; void(T, T, T, T *)&gt;func, bool isElemental=false, bool isGhosted=false, unsigned int dof=1) const</td></tr>
<tr class="memdesc:a0bbac21100bc43baeeea130c94cd019a"><td class="mdescLeft">&#160;</td><td class="mdescRight">initialize a variable vector to a function depends on spatial coords.  <a href="#a0bbac21100bc43baeeea130c94cd019a">More...</a><br /></td></tr>
<tr class="separator:a0bbac21100bc43baeeea130c94cd019a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ade9d1260881dbcb41b2bb60882cc1a77"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ade9d1260881dbcb41b2bb60882cc1a77"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classot_1_1DA.html#ade9d1260881dbcb41b2bb60882cc1a77">setVectorByScalar</a> (T *local, const T *value, bool isElemental=false, bool isGhosted=false, unsigned int dof=1) const</td></tr>
<tr class="memdesc:ade9d1260881dbcb41b2bb60882cc1a77"><td class="mdescLeft">&#160;</td><td class="mdescRight">initialize a variable vector to a function depends on spatial coords.  <a href="#ade9d1260881dbcb41b2bb60882cc1a77">More...</a><br /></td></tr>
<tr class="separator:ade9d1260881dbcb41b2bb60882cc1a77"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a14ba8eac58d6290d64bd6e6472a3112c"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a14ba8eac58d6290d64bd6e6472a3112c"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classot_1_1DA.html#a14ba8eac58d6290d64bd6e6472a3112c">vecTopvtu</a> (T *local, const char *fPrefix, char **nodalVarNames=NULL, bool isElemental=false, bool isGhosted=false, unsigned int dof=1)</td></tr>
<tr class="memdesc:a14ba8eac58d6290d64bd6e6472a3112c"><td class="mdescLeft">&#160;</td><td class="mdescRight">write the vec to pvtu file  <a href="#a14ba8eac58d6290d64bd6e6472a3112c">More...</a><br /></td></tr>
<tr class="separator:a14ba8eac58d6290d64bd6e6472a3112c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a50f4beb0f6e00fb57185a577ef1585ce"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classot_1_1DA.html#a50f4beb0f6e00fb57185a577ef1585ce">getLevel</a> (unsigned int ele) const</td></tr>
<tr class="memdesc:a50f4beb0f6e00fb57185a577ef1585ce"><td class="mdescLeft">&#160;</td><td class="mdescRight">return the level of current octant  <a href="#a50f4beb0f6e00fb57185a577ef1585ce">More...</a><br /></td></tr>
<tr class="separator:a50f4beb0f6e00fb57185a577ef1585ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7270368184723e190fbf39798ab18312"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classot_1_1TreeNode.html">ot::TreeNode</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classot_1_1DA.html#a7270368184723e190fbf39798ab18312">getOctant</a> (unsigned int ele) const</td></tr>
<tr class="memdesc:a7270368184723e190fbf39798ab18312"><td class="mdescLeft">&#160;</td><td class="mdescRight">return the <a class="el" href="classot_1_1TreeNode.html" title="A class to manage octants. ">TreeNode</a> of the current octnat.  <a href="#a7270368184723e190fbf39798ab18312">More...</a><br /></td></tr>
<tr class="separator:a7270368184723e190fbf39798ab18312"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4200e439c95d4f17ec092669a8c05f1a"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a4200e439c95d4f17ec092669a8c05f1a"><td class="memTemplItemLeft" align="right" valign="top">T *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classot_1_1DA.html#a4200e439c95d4f17ec092669a8c05f1a">getVecPointerToDof</a> (T *in, unsigned int dofInex, bool isElemental=false, bool isGhosted=false) const</td></tr>
<tr class="memdesc:a4200e439c95d4f17ec092669a8c05f1a"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns a pointer to a dof index,  <a href="#a4200e439c95d4f17ec092669a8c05f1a">More...</a><br /></td></tr>
<tr class="separator:a4200e439c95d4f17ec092669a8c05f1a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb6f4f6d9c6c632a2895d7600c3b384a"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:acb6f4f6d9c6c632a2895d7600c3b384a"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classot_1_1DA.html#acb6f4f6d9c6c632a2895d7600c3b384a">copyVectors</a> (T *dest, const T *source, bool isElemental=false, bool isGhosted=false, unsigned int dof=1) const</td></tr>
<tr class="memdesc:acb6f4f6d9c6c632a2895d7600c3b384a"><td class="mdescLeft">&#160;</td><td class="mdescRight">copy vecotor to sorce to destination, assumes the same number of dof.  <a href="#acb6f4f6d9c6c632a2895d7600c3b384a">More...</a><br /></td></tr>
<tr class="separator:acb6f4f6d9c6c632a2895d7600c3b384a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa60eab799dbee7ab0a29d18960eee22d"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:aa60eab799dbee7ab0a29d18960eee22d"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classot_1_1DA.html#aa60eab799dbee7ab0a29d18960eee22d">copyVector</a> (T *dest, const T *source, bool isElemental=false, bool isGhosted=false) const</td></tr>
<tr class="memdesc:aa60eab799dbee7ab0a29d18960eee22d"><td class="mdescLeft">&#160;</td><td class="mdescRight">more premitive copy, from source pointer to the dest pointer  <a href="#aa60eab799dbee7ab0a29d18960eee22d">More...</a><br /></td></tr>
<tr class="separator:aa60eab799dbee7ab0a29d18960eee22d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac35234a09603c55770f4dc8e83f7888c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classot_1_1DA.html">ot::DA</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classot_1_1DA.html#ac35234a09603c55770f4dc8e83f7888c">remesh</a> (const <a class="el" href="oda_8h.html#ac96bf616827a93d8d04265c95a356f09">DA_FLAGS::Refine</a> *flags, unsigned int sz, unsigned int grainSz=100, double ld_bal=0.3, unsigned int sfK=2, unsigned int(*getWeight)(const <a class="el" href="classot_1_1TreeNode.html">ot::TreeNode</a> *)=NULL) const</td></tr>
<tr class="memdesc:ac35234a09603c55770f4dc8e83f7888c"><td class="mdescLeft">&#160;</td><td class="mdescRight">: Performs remesh based on the DA_FLAGS::Refine, which specifies no change, refine or coarsen.  <a href="#ac35234a09603c55770f4dc8e83f7888c">More...</a><br /></td></tr>
<tr class="separator:ac35234a09603c55770f4dc8e83f7888c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a49ba42e37b2479a26cb8edb11d59086f"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a49ba42e37b2479a26cb8edb11d59086f"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classot_1_1DA.html#a49ba42e37b2479a26cb8edb11d59086f">intergridTransfer</a> (const T *varIn, T *&amp;varOut, const <a class="el" href="classot_1_1DA.html">ot::DA</a> *newDA, bool isElemental=false, bool isGhosted=false, unsigned int dof=1)</td></tr>
<tr class="memdesc:a49ba42e37b2479a26cb8edb11d59086f"><td class="mdescLeft">&#160;</td><td class="mdescRight">performs grid transfer operations after the remesh.  <a href="#a49ba42e37b2479a26cb8edb11d59086f">More...</a><br /></td></tr>
<tr class="separator:a49ba42e37b2479a26cb8edb11d59086f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa64a3d5a51def56e04fede258d321deb"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:aa64a3d5a51def56e04fede258d321deb"><td class="memTemplItemLeft" align="right" valign="top">int&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classot_1_1DA.html#aa64a3d5a51def56e04fede258d321deb">getFaceNeighborValues</a> (unsigned int eleID, const T *in, T *out, T *coords, unsigned int *neighID, unsigned int face, NeighbourLevel &amp;level, unsigned int dof) const</td></tr>
<tr class="memdesc:aa64a3d5a51def56e04fede258d321deb"><td class="mdescLeft">&#160;</td><td class="mdescRight">computes the face neighbor points for additional computations for a specified direction.  <a href="#aa64a3d5a51def56e04fede258d321deb">More...</a><br /></td></tr>
<tr class="separator:aa64a3d5a51def56e04fede258d321deb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a69f9e3d53e5d587f103020944a1a8dd3"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classot_1_1DA.html#a69f9e3d53e5d587f103020944a1a8dd3">getMortonChildNum</a> (unsigned int eleID) const</td></tr>
<tr class="memdesc:a69f9e3d53e5d587f103020944a1a8dd3"><td class="mdescLeft">&#160;</td><td class="mdescRight">computes the child number of the given octant  <a href="#a69f9e3d53e5d587f103020944a1a8dd3">More...</a><br /></td></tr>
<tr class="separator:a69f9e3d53e5d587f103020944a1a8dd3"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a07649a927d4c350188671998502c0391"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a07649a927d4c350188671998502c0391">&#9670;&nbsp;</a></span>DA() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ot::DA::DA </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; <a class="el" href="classot_1_1TreeNode.html">ot::TreeNode</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>balOct</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MPI_Comm&#160;</td>
          <td class="paramname"><em>comm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>order</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>grainSz</em> = <code>100</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>sfc_tol</em> = <code>0.3</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceot.html#a56125ff5472322284829fbf97534d6f0">SM_TYPE</a>&#160;</td>
          <td class="paramname"><em>smType</em> = <code>SM_TYPE::FEM_CG</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>: Constructor for the <a class="el" href="classot_1_1DA.html">DA</a> data structures </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">in</td><td>: input octree, need to be 2:1 balanced unique sorted octree. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">comm</td><td>MPI global communicator for mesh generation. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">order</td><td>order of the element. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">grainSz</td><td>Number of suggested elements per processor, </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">sfc_tol</td><td><a class="el" href="namespaceSFC.html">SFC</a> partitioning tolerance, </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aca22d409ff768e7600c3e7681b47fac7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aca22d409ff768e7600c3e7681b47fac7">&#9670;&nbsp;</a></span>DA() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ot::DA::DA </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classot_1_1Mesh.html">ot::Mesh</a> *&#160;</td>
          <td class="paramname"><em>pMesh</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>: Create a <a class="el" href="classot_1_1DA.html">DA</a> from a specified mesh </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pMesh</td><td>: input mesh </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa703c2712d0e932c7036ce99a8f49db4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa703c2712d0e932c7036ce99a8f49db4">&#9670;&nbsp;</a></span>DA() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">ot::DA::DA </td>
          <td>(</td>
          <td class="paramtype">std::function&lt; void(T, T, T, T *)&gt;&#160;</td>
          <td class="paramname"><em>func</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>dofSz</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MPI_Comm&#160;</td>
          <td class="paramname"><em>comm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>order</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>interp_tol</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>grainSz</em> = <code>100</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>sfc_tol</em> = <code>0.3</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceot.html#a56125ff5472322284829fbf97534d6f0">SM_TYPE</a>&#160;</td>
          <td class="paramname"><em>smType</em> = <code>SM_TYPE::FEM_CG</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Construct a <a class="el" href="classot_1_1DA.html">DA</a> from a function </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">func</td><td>function to capture </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">dofSz</td><td>size of the degrees of freedoms </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">comm</td><td>MPI communicator </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">order</td><td>element order </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">interp_tol</td><td>interpolation tolerance for func approximation/ capturing </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">grainSz</td><td>number of elements per core. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">sfc_tol</td><td>flexible partitioning tolerance. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">SM_TYPE</td><td>scatter map type </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a8d218d5e8907e2004d59e6aebf9bbdc1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8d218d5e8907e2004d59e6aebf9bbdc1">&#9670;&nbsp;</a></span>DA() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ot::DA::DA </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classPoint.html">Point</a> *&#160;</td>
          <td class="paramname"><em>pts</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>numPts</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classPoint.html">Point</a>&#160;</td>
          <td class="paramname"><em>pt_min</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classPoint.html">Point</a>&#160;</td>
          <td class="paramname"><em>pt_max</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MPI_Comm&#160;</td>
          <td class="paramname"><em>comm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>order</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>grainSz</em> = <code>100</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>sfc_tol</em> = <code>0.3</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceot.html#a56125ff5472322284829fbf97534d6f0">SM_TYPE</a>&#160;</td>
          <td class="paramname"><em>smType</em> = <code>SM_TYPE::FEM_CG</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Construct a new <a class="el" href="classot_1_1DA.html">DA</a> object from specified point set. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pts</td><td>: input points </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">numPts</td><td>: number of points </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">pt_min</td><td>: global min of point </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">pt_max</td><td>: global max of point </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">comm</td><td>: MPI communicator </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">order</td><td>: element order </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">grainSz</td><td>: number of elements per core </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">sfc_tol</td><td>: <a class="el" href="namespaceSFC.html">SFC</a> partition tolerance </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">smType</td><td>: scatter map type </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="aab4e55c9b42b698d80b2da12f639bb3d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aab4e55c9b42b698d80b2da12f639bb3d">&#9670;&nbsp;</a></span>computeTreeNodeOwnerProc()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ot::DA::computeTreeNodeOwnerProc </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classot_1_1TreeNode.html">ot::TreeNode</a> *&#160;</td>
          <td class="paramname"><em>pNodes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>ownerranks</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pNodes</td><td>Nodes that needs to be searched across. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">n</td><td>number of nodes. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname"></td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa60eab799dbee7ab0a29d18960eee22d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa60eab799dbee7ab0a29d18960eee22d">&#9670;&nbsp;</a></span>copyVector()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void ot::DA::copyVector </td>
          <td>(</td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T *&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>isElemental</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>isGhosted</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>more premitive copy, from source pointer to the dest pointer </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">[in/out]</td><td>dest: destination pointer </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">source</td><td>source pointer </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">isElemental</td><td>true if this is an elemental vector/ false otherwise </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">isGhosted</td><td>true if this is a ghosted vector </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="acb6f4f6d9c6c632a2895d7600c3b384a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acb6f4f6d9c6c632a2895d7600c3b384a">&#9670;&nbsp;</a></span>copyVectors()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void ot::DA::copyVectors </td>
          <td>(</td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T *&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>isElemental</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>isGhosted</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>dof</em> = <code>1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>copy vecotor to sorce to destination, assumes the same number of dof. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">[in/out]</td><td>dest: destination pointer </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">source</td><td>source pointer </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">isElemental</td><td>true if this is an elemental vector/ false otherwise </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">isGhosted</td><td>true if this is a ghosted vector </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">dof</td><td>degrees of freedoms </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="abfd158a55b265275afa09175aaa428ad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abfd158a55b265275afa09175aaa428ad">&#9670;&nbsp;</a></span>createVector() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">int ot::DA::createVector </td>
          <td>(</td>
          <td class="paramtype">T *&amp;&#160;</td>
          <td class="paramname"><em>local</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>isElemental</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>isGhosted</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>dof</em> = <code>1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a ODA vector. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">local</td><td>: VecType pointer </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">isElemental</td><td>True if creating a elemental vector (cell data vector) false for a nodal vector </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">isGhosted</td><td>True will allocate ghost nodal values as well, false will only allocate memory for local nodes. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">dof</td><td>degrees of freedoms </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac78a13f67d93b4c277b25471e0a8412d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac78a13f67d93b4c277b25471e0a8412d">&#9670;&nbsp;</a></span>createVector() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">int ot::DA::createVector </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>local</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>isElemental</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>isGhosted</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>dof</em> = <code>1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a ODA vector std::vector&lt;T&gt; </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">local</td><td>: VecType pointer </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">isElemental</td><td>True if creating a elemental vector (cell data vector) false for a nodal vector </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">isGhosted</td><td>True will allocate ghost nodal values as well, false will only allocate memory for local nodes. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">dof</td><td>degrees of freedoms </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="afac164d36b839c9c4e6bd76065b87ad9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afac164d36b839c9c4e6bd76065b87ad9">&#9670;&nbsp;</a></span>destroyVector()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void ot::DA::destroyVector </td>
          <td>(</td>
          <td class="paramtype">T *&amp;&#160;</td>
          <td class="paramname"><em>local</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>deallocates the memory allocated for a vector </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname"></td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a169e4838e1504e933f14eca6b9079281"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a169e4838e1504e933f14eca6b9079281">&#9670;&nbsp;</a></span>eleVecToVecAccumilation()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void ot::DA::eleVecToVecAccumilation </td>
          <td>(</td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T *&#160;</td>
          <td class="paramname"><em>eleVecIn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>eleID</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>dof</em> = <code>1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>computes the elemental vec to global vec accumilation </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">out</td><td>output (need to be ghosted ) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">eleVecIn</td><td>eleVec values. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">eleID</td><td>element ID </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">dof</td><td>degrees of freedoms </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa80c00e420dbe2a77afd9eb706ee3446"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa80c00e420dbe2a77afd9eb706ee3446">&#9670;&nbsp;</a></span>getElementalCoords()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ot::DA::getElementalCoords </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>eleID</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>coords</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>computes the elementCoordinates (based on the nodal placement) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">eleID</td><td>: element ID </td></tr>
    <tr><td class="paramdir"></td><td class="paramname"></td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a95ac73b523469953ff82fe0ae431bf2b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a95ac73b523469953ff82fe0ae431bf2b">&#9670;&nbsp;</a></span>getElementNodalValues()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void ot::DA::getElementNodalValues </td>
          <td>(</td>
          <td class="paramtype">const T *&#160;</td>
          <td class="paramname"><em>in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>eleVecOut</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>eleID</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>dof</em> = <code>1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>computes the element nodal values using interpolation if needed. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">in</td><td>input vector (need to be ghosted ) </td></tr>
    <tr><td class="paramdir"></td><td class="paramname"></td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa64a3d5a51def56e04fede258d321deb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa64a3d5a51def56e04fede258d321deb">&#9670;&nbsp;</a></span>getFaceNeighborValues()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">int ot::DA::getFaceNeighborValues </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>eleID</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T *&#160;</td>
          <td class="paramname"><em>in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>coords</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int *&#160;</td>
          <td class="paramname"><em>neighID</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>face</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">NeighbourLevel &amp;&#160;</td>
          <td class="paramname"><em>level</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>dof</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>computes the face neighbor points for additional computations for a specified direction. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">eleID</td><td>element ID </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">in</td><td>inpute vector </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">out</td><td>output vector values are in the order of the x,y,z size : 4*NodesPerElement </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">coords</td><td>get the corresponding coordinates size: 4*NodesPerElement*m_uiDim; </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">neighID</td><td>face neighbor octant IDs, </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">face</td><td>face direction in {OCT_DIR_LEFT,OCT_IDR_RIGHT,OCT_DIR_DOWN, OCT_DIR_UP,OCT_DIR_BACK,OCT_DIR_FRONT} </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">level</td><td>the level of the neighbour octant with respect to the current octant. returns the number of face neighbours 1/4 for 3D. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a70079babcf7ada81fa1a4a0831a5f221"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a70079babcf7ada81fa1a4a0831a5f221">&#9670;&nbsp;</a></span>getGlobalNodeIndices()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int ot::DA::getGlobalNodeIndices </td>
          <td>(</td>
          <td class="paramtype">DendroIntL *&#160;</td>
          <td class="paramname"><em>nodeIdx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>ele</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the global node indices of a given element,. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">nodeIdx</td><td>global node indices, </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ele</td><td>element id </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a50f4beb0f6e00fb57185a577ef1585ce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a50f4beb0f6e00fb57185a577ef1585ce">&#9670;&nbsp;</a></span>getLevel()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int ot::DA::getLevel </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>ele</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>return the level of current octant </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ele</td><td>elementID of the current octant </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a69f9e3d53e5d587f103020944a1a8dd3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a69f9e3d53e5d587f103020944a1a8dd3">&#9670;&nbsp;</a></span>getMortonChildNum()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int ot::DA::getMortonChildNum </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>eleID</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>computes the child number of the given octant </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">eleID</td><td>element ID returns the Morton child number of the eleID in the octant </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aff20b56a9d1873815cf164d3da4d1b3b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aff20b56a9d1873815cf164d3da4d1b3b">&#9670;&nbsp;</a></span>getNodeIndices()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int ot::DA::getNodeIndices </td>
          <td>(</td>
          <td class="paramtype">DendroIntL *&#160;</td>
          <td class="paramname"><em>nodeIdx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>ele</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>isGhosted</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the local indices to the nodes of the current element. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">nodes</td><td>Indices into the nodes of the given element. Should be allocated by the user prior to calling. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>-1 for error </dd></dl>

</div>
</div>
<a id="a7270368184723e190fbf39798ab18312"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7270368184723e190fbf39798ab18312">&#9670;&nbsp;</a></span>getOctant()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classot_1_1TreeNode.html">ot::TreeNode</a> ot::DA::getOctant </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>ele</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>return the <a class="el" href="classot_1_1TreeNode.html" title="A class to manage octants. ">TreeNode</a> of the current octnat. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ele</td><td>elementID of the current octant </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa0cecbca04037fab197f0282290d996d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa0cecbca04037fab197f0282290d996d">&#9670;&nbsp;</a></span>getOctreeBoundaryNodeIndices()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ot::DA::getOctreeBoundaryNodeIndices </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; unsigned int &gt; &amp;&#160;</td>
          <td class="paramname"><em>bdyIndex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>coords</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>isGhosted</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes the octree writable boundary nodes. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname"></td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a4200e439c95d4f17ec092669a8c05f1a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4200e439c95d4f17ec092669a8c05f1a">&#9670;&nbsp;</a></span>getVecPointerToDof()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">T* ot::DA::getVecPointerToDof </td>
          <td>(</td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>dofInex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>isElemental</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>isGhosted</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>returns a pointer to a dof index, </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">in</td><td>input vector pointer </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">dofInex</td><td>dof index which is the pointer is needed, should be less than dof, value the vector created. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">isElemental</td><td>true if this is an elemental vector/ false otherwise </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">isGhosted</td><td>true if this is a ghosted vector </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>pointer to dofIndex. </dd></dl>

</div>
</div>
<a id="a672aa204e474e22b48a127018dc967fa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a672aa204e474e22b48a127018dc967fa">&#9670;&nbsp;</a></span>ghostedNodalToNodalVec()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void ot::DA::ghostedNodalToNodalVec </td>
          <td>(</td>
          <td class="paramtype">const T *&#160;</td>
          <td class="paramname"><em>gVec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T *&amp;&#160;</td>
          <td class="paramname"><em>local</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>isAllocated</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>dof</em> = <code>1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>convert ghosted nodal vector to local vector (without ghosting) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">gVec</td><td>ghosted vector </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">local</td><td>local vector (assume an allocated vector) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">isAllocated</td><td>true if the out is allocated, false otherwise. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">dof</td><td>degrees of freedoms </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a49ba42e37b2479a26cb8edb11d59086f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a49ba42e37b2479a26cb8edb11d59086f">&#9670;&nbsp;</a></span>intergridTransfer()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void ot::DA::intergridTransfer </td>
          <td>(</td>
          <td class="paramtype">const T *&#160;</td>
          <td class="paramname"><em>varIn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T *&amp;&#160;</td>
          <td class="paramname"><em>varOut</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classot_1_1DA.html">ot::DA</a> *&#160;</td>
          <td class="paramname"><em>newDA</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>isElemental</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>isGhosted</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>dof</em> = <code>1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>performs grid transfer operations after the remesh. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">varIn</td><td>variable defined by oldDA </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">varOut</td><td>variable defined by newDA. interpolate varOut from varIn. (Note: varOut allocated inside the function, no need to allocate outside) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">isElemental</td><td>true if it is an elemental vector </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">isGhosted</td><td>true if allocated ghost vector </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">dof</td><td>degrees of freedoms. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a486603cbf63863eb78741fedb2fe1dc8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a486603cbf63863eb78741fedb2fe1dc8">&#9670;&nbsp;</a></span>isBoundaryOctant()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ot::DA::isBoundaryOctant </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>eleID</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>: returns true if specified eleID is a boundary element false if the eleID is local and not a boundary element. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">eleID</td><td>element ID </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab2482a490d4879c51bbf73940f9b6235"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab2482a490d4879c51bbf73940f9b6235">&#9670;&nbsp;</a></span>nodalVecToGhostedNodal()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void ot::DA::nodalVecToGhostedNodal </td>
          <td>(</td>
          <td class="paramtype">const T *&#160;</td>
          <td class="paramname"><em>in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T *&amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>isAllocated</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>dof</em> = <code>1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>convert nodal local vector with ghosted buffer regions. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">in</td><td>input vector (should be nodal and non ghosted) </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">out</td><td>coverted nodal vector with ghost regions. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">isAllocated</td><td>true if the out is allocated, false otherwise. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">dof</td><td>degrees of freedoms </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac35234a09603c55770f4dc8e83f7888c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac35234a09603c55770f4dc8e83f7888c">&#9670;&nbsp;</a></span>remesh()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classot_1_1DA.html">ot::DA</a> * ot::DA::remesh </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="oda_8h.html#ac96bf616827a93d8d04265c95a356f09">DA_FLAGS::Refine</a> *&#160;</td>
          <td class="paramname"><em>flags</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>sz</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>grainSz</em> = <code>100</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>ld_bal</em> = <code>0.3</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>sfK</em> = <code>2</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int(*)(const <a class="el" href="classot_1_1TreeNode.html">ot::TreeNode</a> *)&#160;</td>
          <td class="paramname"><em>getWeight</em> = <code>NULL</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>: Performs remesh based on the DA_FLAGS::Refine, which specifies no change, refine or coarsen. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">flags</td><td>refinement flags. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">sz</td><td>size of the array flags (needs to be size of the local elements) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">grainSz</td><td>rougly the number of octants per core you need when you create the new da. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ld_tol</td><td>load imbalance tolerance. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">sfK</td><td>splitter fix factor. better to be power of two. increase the value to 128 when running on &gt; 64,000 cores </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>: Specifies the new grid, with new <a class="el" href="classot_1_1DA.html">DA</a>. </dd></dl>

</div>
</div>
<a id="a0bbac21100bc43baeeea130c94cd019a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0bbac21100bc43baeeea130c94cd019a">&#9670;&nbsp;</a></span>setVectorByFunction()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void ot::DA::setVectorByFunction </td>
          <td>(</td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>local</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::function&lt; void(T, T, T, T *)&gt;&#160;</td>
          <td class="paramname"><em>func</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>isElemental</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>isGhosted</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>dof</em> = <code>1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>initialize a variable vector to a function depends on spatial coords. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname"></td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ade9d1260881dbcb41b2bb60882cc1a77"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ade9d1260881dbcb41b2bb60882cc1a77">&#9670;&nbsp;</a></span>setVectorByScalar()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void ot::DA::setVectorByScalar </td>
          <td>(</td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>local</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T *&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>isElemental</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>isGhosted</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>dof</em> = <code>1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>initialize a variable vector to a function depends on spatial coords. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname"></td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a14ba8eac58d6290d64bd6e6472a3112c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a14ba8eac58d6290d64bd6e6472a3112c">&#9670;&nbsp;</a></span>vecTopvtu()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void ot::DA::vecTopvtu </td>
          <td>(</td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>local</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>fPrefix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char **&#160;</td>
          <td class="paramname"><em>nodalVarNames</em> = <code>NULL</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>isElemental</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>isGhosted</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>dof</em> = <code>1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>write the vec to pvtu file </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">local</td><td>variable vector </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">fPrefix</td><td>file name prefix </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">isElemental</td><td>True if creating a elemental vector (cell data vector) false for a nodal vector </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">isGhosted</td><td>True will allocate ghost nodal values as well, false will only allocate memory for local nodes. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">dof</td><td>degrees of freedoms </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a6f23c152d4cb25affa9b2cb2bf5214e5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6f23c152d4cb25affa9b2cb2bf5214e5">&#9670;&nbsp;</a></span>writeToGhostsEnd()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void ot::DA::writeToGhostsEnd </td>
          <td>(</td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>vec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">DA_FLAGS::WriteMode&#160;</td>
          <td class="paramname"><em>mode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>dof</em> = <code>1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sync accumilation across ghost elements. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">vec</td><td>vector pointer </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">mode</td><td>mode of the write to ghost </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">dof</td><td>degrees of freedoms. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>include/<a class="el" href="oda_8h_source.html">oda.h</a></li>
<li>src/<a class="el" href="oda_8cpp.html">oda.cpp</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
