<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Dendro: ot::subDA Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="dendro.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Dendro
   &#160;<span id="projectnumber">5.01</span>
   </div>
   <div id="projectbrief">Dendro in Greek language means tree. The Dendro library is a large scale (262K cores on ORNL&#39;s Titan) distributed memory adaptive octree framework. The main goal of Dendro is to perform large scale multiphysics simulations efficeiently in mordern supercomputers. Dendro consists of efficient parallel data structures and algorithms to perform variational ( finite element) methods and finite difference mthods on 2:1 balanced arbitary adaptive octrees which enables the users to perform simulations raning from black holes (binary black hole mergers) to blood flow in human body, where applications ranging from relativity, astrophysics to biomedical engineering.</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespaceot.html">ot</a></li><li class="navelem"><a class="el" href="classot_1_1subDA.html">subDA</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pro-attribs">Protected Attributes</a> &#124;
<a href="classot_1_1subDA-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">ot::subDA Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p><a class="el" href="classot_1_1subDA.html" title="subDA based on the DA, where to perform computations sub domain of the main domain. ">subDA</a> based on the <a class="el" href="classot_1_1DA.html">DA</a>, where to perform computations sub domain of the main domain.  
 <a href="classot_1_1subDA.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="sub__oda_8h_source.html">sub_oda.h</a>&gt;</code></p>
<div class="dynheader">
Collaboration diagram for ot::subDA:</div>
<div class="dyncontent">
<div class="center"><img src="classot_1_1subDA__coll__graph.png" border="0" usemap="#ot_1_1subDA_coll__map" alt="Collaboration graph"/></div>
<map name="ot_1_1subDA_coll__map" id="ot_1_1subDA_coll__map">
<area shape="rect" id="node2" href="classot_1_1DA.html" title="ot::DA" alt="" coords="5,5,65,32"/>
<area shape="rect" id="node3" href="structot_1_1LoopCounter.html" title=": Simple structure to keep the loop counters " alt="" coords="90,5,205,32"/>
</map>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a35e0ce21db9c82b0be5f8ec6abacc2bf"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classot_1_1subDA.html#a35e0ce21db9c82b0be5f8ec6abacc2bf">subDA</a> (<a class="el" href="classot_1_1DA.html">DA</a> *da, std::function&lt; double(double, double, double) &gt; fx_retain, double *gSize)</td></tr>
<tr class="memdesc:a35e0ce21db9c82b0be5f8ec6abacc2bf"><td class="mdescLeft">&#160;</td><td class="mdescRight">: defult sub da constructor.  <a href="#a35e0ce21db9c82b0be5f8ec6abacc2bf">More...</a><br /></td></tr>
<tr class="separator:a35e0ce21db9c82b0be5f8ec6abacc2bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a58cbc2aef0690ab85011ac41775ff205"><td class="memItemLeft" align="right" valign="top"><a id="a58cbc2aef0690ab85011ac41775ff205"></a>
<a class="el" href="classot_1_1DA.html">ot::DA</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>global_domain</b> ()</td></tr>
<tr class="separator:a58cbc2aef0690ab85011ac41775ff205"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a76579da0c661a31bf6d09f723258bb08"><td class="memItemLeft" align="right" valign="top"><a id="a76579da0c661a31bf6d09f723258bb08"></a>
unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classot_1_1subDA.html#a76579da0c661a31bf6d09f723258bb08">getLocalNodalSz</a> () const</td></tr>
<tr class="memdesc:a76579da0c661a31bf6d09f723258bb08"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns the local nodal size <br /></td></tr>
<tr class="separator:a76579da0c661a31bf6d09f723258bb08"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac1f395c6255a892ebc22d82462c16ef9"><td class="memItemLeft" align="right" valign="top"><a id="ac1f395c6255a892ebc22d82462c16ef9"></a>
unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classot_1_1subDA.html#ac1f395c6255a892ebc22d82462c16ef9">getPreNodalSz</a> () const</td></tr>
<tr class="memdesc:ac1f395c6255a892ebc22d82462c16ef9"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns the pre ghost nodal size <br /></td></tr>
<tr class="separator:ac1f395c6255a892ebc22d82462c16ef9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae36967479b4a4a490d31215da749deef"><td class="memItemLeft" align="right" valign="top"><a id="ae36967479b4a4a490d31215da749deef"></a>
unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classot_1_1subDA.html#ae36967479b4a4a490d31215da749deef">getPostNodalSz</a> () const</td></tr>
<tr class="memdesc:ae36967479b4a4a490d31215da749deef"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns the post nodal size <br /></td></tr>
<tr class="separator:ae36967479b4a4a490d31215da749deef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c21d99dd5ecef6f972fc94ffee385c8"><td class="memItemLeft" align="right" valign="top"><a id="a7c21d99dd5ecef6f972fc94ffee385c8"></a>
unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classot_1_1subDA.html#a7c21d99dd5ecef6f972fc94ffee385c8">getTotalNodalSz</a> () const</td></tr>
<tr class="memdesc:a7c21d99dd5ecef6f972fc94ffee385c8"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns the total nodal size (this includes the ghosted region as well.) <br /></td></tr>
<tr class="separator:a7c21d99dd5ecef6f972fc94ffee385c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abda78f8f9baae58ae9e3064a060bb52d"><td class="memItemLeft" align="right" valign="top"><a id="abda78f8f9baae58ae9e3064a060bb52d"></a>
unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classot_1_1subDA.html#abda78f8f9baae58ae9e3064a060bb52d">getLocalElemSz</a> () const</td></tr>
<tr class="memdesc:abda78f8f9baae58ae9e3064a060bb52d"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns the local elemental size <br /></td></tr>
<tr class="separator:abda78f8f9baae58ae9e3064a060bb52d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab93259edfadb55c5a4eaf914d24e4ba9"><td class="memItemLeft" align="right" valign="top"><a id="ab93259edfadb55c5a4eaf914d24e4ba9"></a>
unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classot_1_1subDA.html#ab93259edfadb55c5a4eaf914d24e4ba9">getTotalElemSz</a> () const</td></tr>
<tr class="memdesc:ab93259edfadb55c5a4eaf914d24e4ba9"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns the local elemental size (includes the ghost elements as well) <br /></td></tr>
<tr class="separator:ab93259edfadb55c5a4eaf914d24e4ba9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab5b0ae9aac68ff46bfc3a4938f817eff"><td class="memItemLeft" align="right" valign="top"><a id="ab5b0ae9aac68ff46bfc3a4938f817eff"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classot_1_1subDA.html#ab5b0ae9aac68ff46bfc3a4938f817eff">isActive</a> () const</td></tr>
<tr class="memdesc:ab5b0ae9aac68ff46bfc3a4938f817eff"><td class="mdescLeft">&#160;</td><td class="mdescRight">see if the current <a class="el" href="classot_1_1DA.html">DA</a> is active <br /></td></tr>
<tr class="separator:ab5b0ae9aac68ff46bfc3a4938f817eff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac59ead34023520b909467d2c3bdb5bd0"><td class="memItemLeft" align="right" valign="top"><a id="ac59ead34023520b909467d2c3bdb5bd0"></a>
unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classot_1_1subDA.html#ac59ead34023520b909467d2c3bdb5bd0">getNumNodesPerElement</a> () const</td></tr>
<tr class="memdesc:ac59ead34023520b909467d2c3bdb5bd0"><td class="mdescLeft">&#160;</td><td class="mdescRight">get number of nodes per element <br /></td></tr>
<tr class="separator:ac59ead34023520b909467d2c3bdb5bd0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7cf1b517a96b701a57b231cd84bd6814"><td class="memItemLeft" align="right" valign="top"><a id="a7cf1b517a96b701a57b231cd84bd6814"></a>
unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classot_1_1subDA.html#a7cf1b517a96b701a57b231cd84bd6814">getElementOrder</a> () const</td></tr>
<tr class="memdesc:a7cf1b517a96b701a57b231cd84bd6814"><td class="mdescLeft">&#160;</td><td class="mdescRight">get element order <br /></td></tr>
<tr class="separator:a7cf1b517a96b701a57b231cd84bd6814"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ace091e28c3fc70b7f39ad518368ba519"><td class="memItemLeft" align="right" valign="top"><a id="ace091e28c3fc70b7f39ad518368ba519"></a>
MPI_Comm&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classot_1_1subDA.html#ace091e28c3fc70b7f39ad518368ba519">getGlobalComm</a> () const</td></tr>
<tr class="memdesc:ace091e28c3fc70b7f39ad518368ba519"><td class="mdescLeft">&#160;</td><td class="mdescRight">: returns the global MPI communicator <br /></td></tr>
<tr class="separator:ace091e28c3fc70b7f39ad518368ba519"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8725e794a81b1c00ab69e65229053e7e"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classot_1_1Mesh.html">ot::Mesh</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classot_1_1subDA.html#a8725e794a81b1c00ab69e65229053e7e">getMesh</a> () const</td></tr>
<tr class="memdesc:a8725e794a81b1c00ab69e65229053e7e"><td class="mdescLeft">&#160;</td><td class="mdescRight">: returns node local to node global map  <a href="#a8725e794a81b1c00ab69e65229053e7e">More...</a><br /></td></tr>
<tr class="separator:a8725e794a81b1c00ab69e65229053e7e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa8ce84fb70f5d4075d0f849f6e31b1d2"><td class="memItemLeft" align="right" valign="top"><a id="aa8ce84fb70f5d4075d0f849f6e31b1d2"></a>
MPI_Comm&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classot_1_1subDA.html#aa8ce84fb70f5d4075d0f849f6e31b1d2">getCommActive</a> () const</td></tr>
<tr class="memdesc:aa8ce84fb70f5d4075d0f849f6e31b1d2"><td class="mdescLeft">&#160;</td><td class="mdescRight">: returns the active MPI sub com of the global communicator <br /></td></tr>
<tr class="separator:aa8ce84fb70f5d4075d0f849f6e31b1d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8040f2365a8ec865ffb568f6971602e0"><td class="memItemLeft" align="right" valign="top"><a id="a8040f2365a8ec865ffb568f6971602e0"></a>
unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classot_1_1subDA.html#a8040f2365a8ec865ffb568f6971602e0">getNpesAll</a> () const</td></tr>
<tr class="memdesc:a8040f2365a8ec865ffb568f6971602e0"><td class="mdescLeft">&#160;</td><td class="mdescRight">: global mpi com. size <br /></td></tr>
<tr class="separator:a8040f2365a8ec865ffb568f6971602e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a71d8ece3afda11c1887caaaf0a0ea29b"><td class="memItemLeft" align="right" valign="top"><a id="a71d8ece3afda11c1887caaaf0a0ea29b"></a>
unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classot_1_1subDA.html#a71d8ece3afda11c1887caaaf0a0ea29b">getNpesActive</a> () const</td></tr>
<tr class="memdesc:a71d8ece3afda11c1887caaaf0a0ea29b"><td class="mdescLeft">&#160;</td><td class="mdescRight">: number of processors active <br /></td></tr>
<tr class="separator:a71d8ece3afda11c1887caaaf0a0ea29b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af8c9bea277ffd20aaafb944b2b755ccd"><td class="memItemLeft" align="right" valign="top"><a id="af8c9bea277ffd20aaafb944b2b755ccd"></a>
unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classot_1_1subDA.html#af8c9bea277ffd20aaafb944b2b755ccd">getRankAll</a> () const</td></tr>
<tr class="memdesc:af8c9bea277ffd20aaafb944b2b755ccd"><td class="mdescLeft">&#160;</td><td class="mdescRight">: rank with respect to the global comm. <br /></td></tr>
<tr class="separator:af8c9bea277ffd20aaafb944b2b755ccd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a479be5304a8d73b2097e4f3ac0f22d92"><td class="memItemLeft" align="right" valign="top"><a id="a479be5304a8d73b2097e4f3ac0f22d92"></a>
unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classot_1_1subDA.html#a479be5304a8d73b2097e4f3ac0f22d92">getRankActive</a> () const</td></tr>
<tr class="memdesc:a479be5304a8d73b2097e4f3ac0f22d92"><td class="mdescLeft">&#160;</td><td class="mdescRight">: rank w.r.t active comm. <br /></td></tr>
<tr class="separator:a479be5304a8d73b2097e4f3ac0f22d92"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab638f20c1163045b6c5c74bcfa912bd4"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classot_1_1subDA.html#ab638f20c1163045b6c5c74bcfa912bd4">isBoundaryOctant</a> (unsigned int eleID) const</td></tr>
<tr class="memdesc:ab638f20c1163045b6c5c74bcfa912bd4"><td class="mdescLeft">&#160;</td><td class="mdescRight">: returns true if specified eleID is a boundary element false if the eleID is local and not a boundary element.  <a href="#ab638f20c1163045b6c5c74bcfa912bd4">More...</a><br /></td></tr>
<tr class="separator:ab638f20c1163045b6c5c74bcfa912bd4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a26606bbf5242666eb2b757eeff900453"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classot_1_1subDA.html#a26606bbf5242666eb2b757eeff900453">getElementalCoords</a> (unsigned int eleID, double *coords) const</td></tr>
<tr class="memdesc:a26606bbf5242666eb2b757eeff900453"><td class="mdescLeft">&#160;</td><td class="mdescRight">computes the elementCoordinates (based on the nodal placement)  <a href="#a26606bbf5242666eb2b757eeff900453">More...</a><br /></td></tr>
<tr class="separator:a26606bbf5242666eb2b757eeff900453"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab4ae26adeec5c3e22f8e70ed996233e1"><td class="memItemLeft" align="right" valign="top"><a id="ab4ae26adeec5c3e22f8e70ed996233e1"></a>
const <a class="el" href="classRefElement.html">RefElement</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classot_1_1subDA.html#ab4ae26adeec5c3e22f8e70ed996233e1">getReferenceElement</a> () const</td></tr>
<tr class="memdesc:ab4ae26adeec5c3e22f8e70ed996233e1"><td class="mdescLeft">&#160;</td><td class="mdescRight">get a constant pointer for the reference element <br /></td></tr>
<tr class="separator:ab4ae26adeec5c3e22f8e70ed996233e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a204b75d51781fc26063729d4f62dcbc3"><td class="memItemLeft" align="right" valign="top"><a id="a204b75d51781fc26063729d4f62dcbc3"></a>
unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classot_1_1subDA.html#a204b75d51781fc26063729d4f62dcbc3">getElementSize</a> () const</td></tr>
<tr class="memdesc:a204b75d51781fc26063729d4f62dcbc3"><td class="mdescLeft">&#160;</td><td class="mdescRight">: get the number of local elements. <br /></td></tr>
<tr class="separator:a204b75d51781fc26063729d4f62dcbc3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a59f7697687258d1c817ce1c5aa21834d"><td class="memItemLeft" align="right" valign="top"><a id="a59f7697687258d1c817ce1c5aa21834d"></a>
unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classot_1_1subDA.html#a59f7697687258d1c817ce1c5aa21834d">getPreGhostElementSize</a> () const</td></tr>
<tr class="memdesc:a59f7697687258d1c817ce1c5aa21834d"><td class="mdescLeft">&#160;</td><td class="mdescRight">: get the number of pre-ghost element size <br /></td></tr>
<tr class="separator:a59f7697687258d1c817ce1c5aa21834d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2f02626dbff180a5d3cdc2188a77828c"><td class="memItemLeft" align="right" valign="top"><a id="a2f02626dbff180a5d3cdc2188a77828c"></a>
unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classot_1_1subDA.html#a2f02626dbff180a5d3cdc2188a77828c">getPostGhostElementSize</a> () const</td></tr>
<tr class="memdesc:a2f02626dbff180a5d3cdc2188a77828c"><td class="mdescLeft">&#160;</td><td class="mdescRight">: get the number of post-ghost element size <br /></td></tr>
<tr class="separator:a2f02626dbff180a5d3cdc2188a77828c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2993d5c1cbe87aceb2e6197751be0dc4"><td class="memItemLeft" align="right" valign="top"><a id="a2993d5c1cbe87aceb2e6197751be0dc4"></a>
unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classot_1_1subDA.html#a2993d5c1cbe87aceb2e6197751be0dc4">getPreAndPostGhostNodeSize</a> () const</td></tr>
<tr class="memdesc:a2993d5c1cbe87aceb2e6197751be0dc4"><td class="mdescLeft">&#160;</td><td class="mdescRight">: get the number of pre and post ghost elements <br /></td></tr>
<tr class="separator:a2993d5c1cbe87aceb2e6197751be0dc4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a66107fe44adfeeebbfbe14e824e6e670"><td class="memItemLeft" align="right" valign="top"><a id="a66107fe44adfeeebbfbe14e824e6e670"></a>
unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classot_1_1subDA.html#a66107fe44adfeeebbfbe14e824e6e670">getGhostedElementSize</a> () const</td></tr>
<tr class="memdesc:a66107fe44adfeeebbfbe14e824e6e670"><td class="mdescLeft">&#160;</td><td class="mdescRight">: get the number of pre and post ghost elements <br /></td></tr>
<tr class="separator:a66107fe44adfeeebbfbe14e824e6e670"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad110f66cba21f45fbbb6b1dc838150cf"><td class="memItemLeft" align="right" valign="top"><a id="ad110f66cba21f45fbbb6b1dc838150cf"></a>
unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classot_1_1subDA.html#ad110f66cba21f45fbbb6b1dc838150cf">getMaxDepth</a> () const</td></tr>
<tr class="memdesc:ad110f66cba21f45fbbb6b1dc838150cf"><td class="mdescLeft">&#160;</td><td class="mdescRight">: get the max depth of the octree <br /></td></tr>
<tr class="separator:ad110f66cba21f45fbbb6b1dc838150cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aff403e9ace1878665225f38330f142d0"><td class="memItemLeft" align="right" valign="top"><a id="aff403e9ace1878665225f38330f142d0"></a>
unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classot_1_1subDA.html#aff403e9ace1878665225f38330f142d0">getDimension</a> () const</td></tr>
<tr class="memdesc:aff403e9ace1878665225f38330f142d0"><td class="mdescLeft">&#160;</td><td class="mdescRight">: get the dimensionality of the octree <br /></td></tr>
<tr class="separator:aff403e9ace1878665225f38330f142d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a56aa20897ab340a6e5c69cee310a1a7e"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a56aa20897ab340a6e5c69cee310a1a7e"><td class="memTemplItemLeft" align="right" valign="top">int&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classot_1_1subDA.html#a56aa20897ab340a6e5c69cee310a1a7e">createVector</a> (T *&amp;local, bool isElemental=false, bool isGhosted=false, unsigned int dof=1) const</td></tr>
<tr class="memdesc:a56aa20897ab340a6e5c69cee310a1a7e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a ODA vector.  <a href="#a56aa20897ab340a6e5c69cee310a1a7e">More...</a><br /></td></tr>
<tr class="separator:a56aa20897ab340a6e5c69cee310a1a7e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a384bbf133a56f573658be57fe143d227"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a384bbf133a56f573658be57fe143d227"><td class="memTemplItemLeft" align="right" valign="top">int&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classot_1_1subDA.html#a384bbf133a56f573658be57fe143d227">createVector</a> (std::vector&lt; T &gt; &amp;local, bool isElemental=false, bool isGhosted=false, unsigned int dof=1) const</td></tr>
<tr class="memdesc:a384bbf133a56f573658be57fe143d227"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a ODA vector std::vector&lt;T&gt;  <a href="#a384bbf133a56f573658be57fe143d227">More...</a><br /></td></tr>
<tr class="separator:a384bbf133a56f573658be57fe143d227"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aafe5e5697dbc68c719dc59059cf61bca"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:aafe5e5697dbc68c719dc59059cf61bca"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classot_1_1subDA.html#aafe5e5697dbc68c719dc59059cf61bca">destroyVector</a> (T *&amp;local) const</td></tr>
<tr class="memdesc:aafe5e5697dbc68c719dc59059cf61bca"><td class="mdescLeft">&#160;</td><td class="mdescRight">deallocates the memory allocated for a vector  <a href="#aafe5e5697dbc68c719dc59059cf61bca">More...</a><br /></td></tr>
<tr class="separator:aafe5e5697dbc68c719dc59059cf61bca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a61c9c441f907e4160e8f95d5caa39928"><td class="memTemplParams" colspan="2"><a id="a61c9c441f907e4160e8f95d5caa39928"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a61c9c441f907e4160e8f95d5caa39928"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>destroyVector</b> (std::vector&lt; T &gt; &amp;local) const</td></tr>
<tr class="separator:a61c9c441f907e4160e8f95d5caa39928"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acef10cf3d1d9cb28b10e0bd400717dda"><td class="memTemplParams" colspan="2"><a id="acef10cf3d1d9cb28b10e0bd400717dda"></a>
template&lt;ot::DA_FLAGS::LoopType type&gt; </td></tr>
<tr class="memitem:acef10cf3d1d9cb28b10e0bd400717dda"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classot_1_1subDA.html#acef10cf3d1d9cb28b10e0bd400717dda">init</a> ()</td></tr>
<tr class="memdesc:acef10cf3d1d9cb28b10e0bd400717dda"><td class="mdescLeft">&#160;</td><td class="mdescRight">initialize the loop counters. <br /></td></tr>
<tr class="separator:acef10cf3d1d9cb28b10e0bd400717dda"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc06b757155023de2fa1d20454644de6"><td class="memItemLeft" align="right" valign="top"><a id="abc06b757155023de2fa1d20454644de6"></a>
unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classot_1_1subDA.html#abc06b757155023de2fa1d20454644de6">curr</a> ()</td></tr>
<tr class="memdesc:abc06b757155023de2fa1d20454644de6"><td class="mdescLeft">&#160;</td><td class="mdescRight">get the current elmenent in the iteration <br /></td></tr>
<tr class="separator:abc06b757155023de2fa1d20454644de6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab821a56ed9700938c8823a0564e927b1"><td class="memTemplParams" colspan="2"><a id="ab821a56ed9700938c8823a0564e927b1"></a>
template&lt;ot::DA_FLAGS::LoopType type&gt; </td></tr>
<tr class="memitem:ab821a56ed9700938c8823a0564e927b1"><td class="memTemplItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classot_1_1subDA.html#ab821a56ed9700938c8823a0564e927b1">end</a> ()</td></tr>
<tr class="memdesc:ab821a56ed9700938c8823a0564e927b1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns if the current element has reached end or not. <br /></td></tr>
<tr class="separator:ab821a56ed9700938c8823a0564e927b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a70a8db6201d640fe09188c23b32fbae3"><td class="memTemplParams" colspan="2"><a id="a70a8db6201d640fe09188c23b32fbae3"></a>
template&lt;ot::DA_FLAGS::LoopType type&gt; </td></tr>
<tr class="memitem:a70a8db6201d640fe09188c23b32fbae3"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classot_1_1subDA.html#a70a8db6201d640fe09188c23b32fbae3">next</a> ()</td></tr>
<tr class="memdesc:a70a8db6201d640fe09188c23b32fbae3"><td class="mdescLeft">&#160;</td><td class="mdescRight">: increment it to the next element. <br /></td></tr>
<tr class="separator:a70a8db6201d640fe09188c23b32fbae3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a21724a2ea835d8c771a9b73294d37451"><td class="memTemplParams" colspan="2"><a id="a21724a2ea835d8c771a9b73294d37451"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a21724a2ea835d8c771a9b73294d37451"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classot_1_1subDA.html#a21724a2ea835d8c771a9b73294d37451">readFromGhostBegin</a> (T *vec, unsigned int dof=1)</td></tr>
<tr class="memdesc:a21724a2ea835d8c771a9b73294d37451"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initiate the ghost nodal value exchange. <br /></td></tr>
<tr class="separator:a21724a2ea835d8c771a9b73294d37451"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a781c61932265cc0e505035604a15e425"><td class="memTemplParams" colspan="2"><a id="a781c61932265cc0e505035604a15e425"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a781c61932265cc0e505035604a15e425"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classot_1_1subDA.html#a781c61932265cc0e505035604a15e425">readFromGhostEnd</a> (T *vec, unsigned int dof=1)</td></tr>
<tr class="memdesc:a781c61932265cc0e505035604a15e425"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sync the ghost element exchange. <br /></td></tr>
<tr class="separator:a781c61932265cc0e505035604a15e425"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae8f9c39ad75a63a55997798e154e9c0d"><td class="memTemplParams" colspan="2"><a id="ae8f9c39ad75a63a55997798e154e9c0d"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:ae8f9c39ad75a63a55997798e154e9c0d"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classot_1_1subDA.html#ae8f9c39ad75a63a55997798e154e9c0d">writeToGhostsBegin</a> (T *vec, unsigned int dof=1)</td></tr>
<tr class="memdesc:ae8f9c39ad75a63a55997798e154e9c0d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initiate accumilation across ghost elements. <br /></td></tr>
<tr class="separator:ae8f9c39ad75a63a55997798e154e9c0d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aff2c532d6d3c0bbf822199a7a6321dd2"><td class="memTemplParams" colspan="2"><a id="aff2c532d6d3c0bbf822199a7a6321dd2"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:aff2c532d6d3c0bbf822199a7a6321dd2"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classot_1_1subDA.html#aff2c532d6d3c0bbf822199a7a6321dd2">writeToGhostsEnd</a> (T *vec, unsigned int dof=1)</td></tr>
<tr class="memdesc:aff2c532d6d3c0bbf822199a7a6321dd2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sync accumilation across ghost elements. <br /></td></tr>
<tr class="separator:aff2c532d6d3c0bbf822199a7a6321dd2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac7d0fa5f47a217afbbbc2638ffef7c55"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ac7d0fa5f47a217afbbbc2638ffef7c55"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classot_1_1subDA.html#ac7d0fa5f47a217afbbbc2638ffef7c55">nodalVecToGhostedNodal</a> (const T *in, T *&amp;out, bool isAllocated=false, unsigned int dof=1) const</td></tr>
<tr class="memdesc:ac7d0fa5f47a217afbbbc2638ffef7c55"><td class="mdescLeft">&#160;</td><td class="mdescRight">convert nodal local vector with ghosted buffer regions.  <a href="#ac7d0fa5f47a217afbbbc2638ffef7c55">More...</a><br /></td></tr>
<tr class="separator:ac7d0fa5f47a217afbbbc2638ffef7c55"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2aed4e5133cf948a466c649317260269"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a2aed4e5133cf948a466c649317260269"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classot_1_1subDA.html#a2aed4e5133cf948a466c649317260269">ghostedNodalToNodalVec</a> (const T *gVec, T *&amp;local, bool isAllocated=false, unsigned int dof=1) const</td></tr>
<tr class="memdesc:a2aed4e5133cf948a466c649317260269"><td class="mdescLeft">&#160;</td><td class="mdescRight">convert ghosted nodal vector to local vector (without ghosting)  <a href="#a2aed4e5133cf948a466c649317260269">More...</a><br /></td></tr>
<tr class="separator:a2aed4e5133cf948a466c649317260269"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae642a22eea82cfa329b6d16507526c50"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ae642a22eea82cfa329b6d16507526c50"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classot_1_1subDA.html#ae642a22eea82cfa329b6d16507526c50">getElementNodalValues</a> (const T *in, T *eleVecOut, unsigned int eleID, unsigned int dof=1) const</td></tr>
<tr class="memdesc:ae642a22eea82cfa329b6d16507526c50"><td class="mdescLeft">&#160;</td><td class="mdescRight">computes the element nodal values using interpolation if needed.  <a href="#ae642a22eea82cfa329b6d16507526c50">More...</a><br /></td></tr>
<tr class="separator:ae642a22eea82cfa329b6d16507526c50"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af729167f9e7a72b5a2a8e98ef66cd7ad"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:af729167f9e7a72b5a2a8e98ef66cd7ad"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classot_1_1subDA.html#af729167f9e7a72b5a2a8e98ef66cd7ad">eleVecToVecAccumilation</a> (T *out, const T *eleVecIn, unsigned int eleID, unsigned int dof=1) const</td></tr>
<tr class="memdesc:af729167f9e7a72b5a2a8e98ef66cd7ad"><td class="mdescLeft">&#160;</td><td class="mdescRight">computes the elemental vec to global vec accumilation  <a href="#af729167f9e7a72b5a2a8e98ef66cd7ad">More...</a><br /></td></tr>
<tr class="separator:af729167f9e7a72b5a2a8e98ef66cd7ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a42ace0325fd34c16c2502608808d39c2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classot_1_1subDA.html#a42ace0325fd34c16c2502608808d39c2">getOctreeBoundaryNodeIndices</a> (std::vector&lt; unsigned int &gt; &amp;bdyIndex, std::vector&lt; double &gt; &amp;coords, bool isGhosted=false)</td></tr>
<tr class="memdesc:a42ace0325fd34c16c2502608808d39c2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the octree writable boundary nodes.  <a href="#a42ace0325fd34c16c2502608808d39c2">More...</a><br /></td></tr>
<tr class="separator:a42ace0325fd34c16c2502608808d39c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeae4eeb0c9533278c2e63ab918c53080"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classot_1_1subDA.html#aeae4eeb0c9533278c2e63ab918c53080">getNodeIndices</a> (DendroIntL *nodeIdx, unsigned int ele, bool isGhosted) const</td></tr>
<tr class="memdesc:aeae4eeb0c9533278c2e63ab918c53080"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the local indices to the nodes of the current element.  <a href="#aeae4eeb0c9533278c2e63ab918c53080">More...</a><br /></td></tr>
<tr class="separator:aeae4eeb0c9533278c2e63ab918c53080"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a93dfe2b167170822f416426e262ab831"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classot_1_1subDA.html#a93dfe2b167170822f416426e262ab831">getGlobalNodeIndices</a> (DendroIntL *nodeIdx, unsigned int ele) const</td></tr>
<tr class="memdesc:a93dfe2b167170822f416426e262ab831"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the global node indices of a given element,.  <a href="#a93dfe2b167170822f416426e262ab831">More...</a><br /></td></tr>
<tr class="separator:a93dfe2b167170822f416426e262ab831"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a80d19e2233cb7b7f518a8e0fa74060bf"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a80d19e2233cb7b7f518a8e0fa74060bf"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classot_1_1subDA.html#a80d19e2233cb7b7f518a8e0fa74060bf">setVectorByFunction</a> (T *local, std::function&lt; void(T, T, T, T *)&gt;func, bool isElemental=false, bool isGhosted=false, unsigned int dof=1) const</td></tr>
<tr class="memdesc:a80d19e2233cb7b7f518a8e0fa74060bf"><td class="mdescLeft">&#160;</td><td class="mdescRight">initialize a variable vector to a function depends on spatial coords.  <a href="#a80d19e2233cb7b7f518a8e0fa74060bf">More...</a><br /></td></tr>
<tr class="separator:a80d19e2233cb7b7f518a8e0fa74060bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a911d5a75150ee552090a4c6e43ee9947"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a911d5a75150ee552090a4c6e43ee9947"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classot_1_1subDA.html#a911d5a75150ee552090a4c6e43ee9947">setVectorByScalar</a> (T *local, const T *value, bool isElemental=false, bool isGhosted=false, unsigned int dof=1) const</td></tr>
<tr class="memdesc:a911d5a75150ee552090a4c6e43ee9947"><td class="mdescLeft">&#160;</td><td class="mdescRight">initialize a variable vector to a function depends on spatial coords.  <a href="#a911d5a75150ee552090a4c6e43ee9947">More...</a><br /></td></tr>
<tr class="separator:a911d5a75150ee552090a4c6e43ee9947"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a809466e1f727e08c7b79c73d4be90930"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a809466e1f727e08c7b79c73d4be90930"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classot_1_1subDA.html#a809466e1f727e08c7b79c73d4be90930">vecTopvtu</a> (T *local, const char *fPrefix, char **nodalVarNames=NULL, bool isElemental=false, bool isGhosted=false, unsigned int dof=1)</td></tr>
<tr class="memdesc:a809466e1f727e08c7b79c73d4be90930"><td class="mdescLeft">&#160;</td><td class="mdescRight">write the vec to pvtu file  <a href="#a809466e1f727e08c7b79c73d4be90930">More...</a><br /></td></tr>
<tr class="separator:a809466e1f727e08c7b79c73d4be90930"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a59e0f22aca4f07d8e15a8ed70c761f98"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classot_1_1subDA.html#a59e0f22aca4f07d8e15a8ed70c761f98">getLevel</a> (unsigned int ele) const</td></tr>
<tr class="memdesc:a59e0f22aca4f07d8e15a8ed70c761f98"><td class="mdescLeft">&#160;</td><td class="mdescRight">return the level of current octant  <a href="#a59e0f22aca4f07d8e15a8ed70c761f98">More...</a><br /></td></tr>
<tr class="separator:a59e0f22aca4f07d8e15a8ed70c761f98"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9e3c3c96ee5c35c47e153c2e71088356"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classot_1_1TreeNode.html">ot::TreeNode</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classot_1_1subDA.html#a9e3c3c96ee5c35c47e153c2e71088356">getOctant</a> (unsigned int ele) const</td></tr>
<tr class="memdesc:a9e3c3c96ee5c35c47e153c2e71088356"><td class="mdescLeft">&#160;</td><td class="mdescRight">return the <a class="el" href="classot_1_1TreeNode.html" title="A class to manage octants. ">TreeNode</a> of the current octnat.  <a href="#a9e3c3c96ee5c35c47e153c2e71088356">More...</a><br /></td></tr>
<tr class="separator:a9e3c3c96ee5c35c47e153c2e71088356"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4cbff6412365bc65a213a86dc937f711"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a4cbff6412365bc65a213a86dc937f711"><td class="memTemplItemLeft" align="right" valign="top">T *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classot_1_1subDA.html#a4cbff6412365bc65a213a86dc937f711">getVecPointerToDof</a> (T *in, unsigned int dofInex, bool isElemental=false, bool isGhosted=false) const</td></tr>
<tr class="memdesc:a4cbff6412365bc65a213a86dc937f711"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns a pointer to a dof index,  <a href="#a4cbff6412365bc65a213a86dc937f711">More...</a><br /></td></tr>
<tr class="separator:a4cbff6412365bc65a213a86dc937f711"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4da2962a4fa74a47dd6f24ba5c597ca4"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a4da2962a4fa74a47dd6f24ba5c597ca4"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classot_1_1subDA.html#a4da2962a4fa74a47dd6f24ba5c597ca4">copyVectors</a> (T *dest, const T *source, bool isElemental=false, bool isGhosted=false, unsigned int dof=1) const</td></tr>
<tr class="memdesc:a4da2962a4fa74a47dd6f24ba5c597ca4"><td class="mdescLeft">&#160;</td><td class="mdescRight">copy vecotor to sorce to destination, assumes the same number of dof.  <a href="#a4da2962a4fa74a47dd6f24ba5c597ca4">More...</a><br /></td></tr>
<tr class="separator:a4da2962a4fa74a47dd6f24ba5c597ca4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a00ae80d9f8417fe20081fc662d95a6fb"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a00ae80d9f8417fe20081fc662d95a6fb"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classot_1_1subDA.html#a00ae80d9f8417fe20081fc662d95a6fb">copyVector</a> (T *dest, const T *source, bool isElemental=false, bool isGhosted=false) const</td></tr>
<tr class="memdesc:a00ae80d9f8417fe20081fc662d95a6fb"><td class="mdescLeft">&#160;</td><td class="mdescRight">more premitive copy, from source pointer to the dest pointer  <a href="#a00ae80d9f8417fe20081fc662d95a6fb">More...</a><br /></td></tr>
<tr class="separator:a00ae80d9f8417fe20081fc662d95a6fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2095453f1150e81cbe4484b082cd4068"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classot_1_1DA.html">ot::DA</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classot_1_1subDA.html#a2095453f1150e81cbe4484b082cd4068">remesh</a> (const <a class="el" href="oda_8h.html#ac96bf616827a93d8d04265c95a356f09">DA_FLAGS::Refine</a> *flags, unsigned int sz, unsigned int grainSz=100, double ld_bal=0.3, unsigned int sfK=2) const</td></tr>
<tr class="memdesc:a2095453f1150e81cbe4484b082cd4068"><td class="mdescLeft">&#160;</td><td class="mdescRight">: Performs remesh based on the DA_FLAGS::Refine, which specifies no change, refine or coarsen.  <a href="#a2095453f1150e81cbe4484b082cd4068">More...</a><br /></td></tr>
<tr class="separator:a2095453f1150e81cbe4484b082cd4068"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac9931b07b79a9f43f19e1c06876de338"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ac9931b07b79a9f43f19e1c06876de338"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classot_1_1subDA.html#ac9931b07b79a9f43f19e1c06876de338">intergridTransfer</a> (const T *varIn, T *&amp;varOut, const <a class="el" href="classot_1_1DA.html">ot::DA</a> *newDA, bool isElemental=false, bool isGhosted=false, unsigned int dof=1)</td></tr>
<tr class="memdesc:ac9931b07b79a9f43f19e1c06876de338"><td class="mdescLeft">&#160;</td><td class="mdescRight">performs grid transfer operations after the remesh.  <a href="#ac9931b07b79a9f43f19e1c06876de338">More...</a><br /></td></tr>
<tr class="separator:ac9931b07b79a9f43f19e1c06876de338"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a737ee05a2cabc91ea17e39838c19171f"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a737ee05a2cabc91ea17e39838c19171f"><td class="memTemplItemLeft" align="right" valign="top">int&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classot_1_1subDA.html#a737ee05a2cabc91ea17e39838c19171f">getFaceNeighborValues</a> (unsigned int eleID, const T *in, T *out, T *coords, unsigned int *neighID, unsigned int face, NeighbourLevel &amp;level) const</td></tr>
<tr class="memdesc:a737ee05a2cabc91ea17e39838c19171f"><td class="mdescLeft">&#160;</td><td class="mdescRight">computes the face neighbor points for additional computations for a specified direction.  <a href="#a737ee05a2cabc91ea17e39838c19171f">More...</a><br /></td></tr>
<tr class="separator:a737ee05a2cabc91ea17e39838c19171f"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-attribs"></a>
Protected Attributes</h2></td></tr>
<tr class="memitem:ae1dfb051f391f0346a7d7f91f8099fc6"><td class="memItemLeft" align="right" valign="top"><a id="ae1dfb051f391f0346a7d7f91f8099fc6"></a>
<a class="el" href="classot_1_1DA.html">ot::DA</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classot_1_1subDA.html#ae1dfb051f391f0346a7d7f91f8099fc6">m_da</a></td></tr>
<tr class="memdesc:ae1dfb051f391f0346a7d7f91f8099fc6"><td class="mdescLeft">&#160;</td><td class="mdescRight">: parent da <br /></td></tr>
<tr class="separator:ae1dfb051f391f0346a7d7f91f8099fc6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a02cd5908cd44bc65deb1a7598f5eb1e3"><td class="memItemLeft" align="right" valign="top"><a id="a02cd5908cd44bc65deb1a7598f5eb1e3"></a>
std::vector&lt; unsigned char &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classot_1_1subDA.html#a02cd5908cd44bc65deb1a7598f5eb1e3">m_ucpSkipList</a></td></tr>
<tr class="memdesc:a02cd5908cd44bc65deb1a7598f5eb1e3"><td class="mdescLeft">&#160;</td><td class="mdescRight">:elemental skip list <br /></td></tr>
<tr class="separator:a02cd5908cd44bc65deb1a7598f5eb1e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a98b21fb857d4e79148cbd23fc645a12a"><td class="memItemLeft" align="right" valign="top"><a id="a98b21fb857d4e79148cbd23fc645a12a"></a>
std::vector&lt; unsigned char &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classot_1_1subDA.html#a98b21fb857d4e79148cbd23fc645a12a">m_ucpSkipNodeList</a></td></tr>
<tr class="memdesc:a98b21fb857d4e79148cbd23fc645a12a"><td class="mdescLeft">&#160;</td><td class="mdescRight">:nodal skip list <br /></td></tr>
<tr class="separator:a98b21fb857d4e79148cbd23fc645a12a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a430f075877efbbe2d3b61456510a80d5"><td class="memItemLeft" align="right" valign="top"><a id="a430f075877efbbe2d3b61456510a80d5"></a>
unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classot_1_1subDA.html#a430f075877efbbe2d3b61456510a80d5">m_uiLocalElementSize</a></td></tr>
<tr class="memdesc:a430f075877efbbe2d3b61456510a80d5"><td class="mdescLeft">&#160;</td><td class="mdescRight">: local element size <br /></td></tr>
<tr class="separator:a430f075877efbbe2d3b61456510a80d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a60d2672b14a6da3805c27ecfacf43321"><td class="memItemLeft" align="right" valign="top"><a id="a60d2672b14a6da3805c27ecfacf43321"></a>
unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classot_1_1subDA.html#a60d2672b14a6da3805c27ecfacf43321">m_uiPreGhostElementSize</a></td></tr>
<tr class="memdesc:a60d2672b14a6da3805c27ecfacf43321"><td class="mdescLeft">&#160;</td><td class="mdescRight">: pre ghost element size <br /></td></tr>
<tr class="separator:a60d2672b14a6da3805c27ecfacf43321"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ace1f5c30b13f88aec75ad69fd94e61aa"><td class="memItemLeft" align="right" valign="top"><a id="ace1f5c30b13f88aec75ad69fd94e61aa"></a>
unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classot_1_1subDA.html#ace1f5c30b13f88aec75ad69fd94e61aa">m_uiPostGhostElementSize</a></td></tr>
<tr class="memdesc:ace1f5c30b13f88aec75ad69fd94e61aa"><td class="mdescLeft">&#160;</td><td class="mdescRight">: post ghost element size <br /></td></tr>
<tr class="separator:ace1f5c30b13f88aec75ad69fd94e61aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa673f5c55b893d41c0b764449418d799"><td class="memItemLeft" align="right" valign="top"><a id="aa673f5c55b893d41c0b764449418d799"></a>
unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classot_1_1subDA.html#aa673f5c55b893d41c0b764449418d799">m_uiLocalNodeSize</a></td></tr>
<tr class="memdesc:aa673f5c55b893d41c0b764449418d799"><td class="mdescLeft">&#160;</td><td class="mdescRight">: Local node size <br /></td></tr>
<tr class="separator:aa673f5c55b893d41c0b764449418d799"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3831a134c2f14ab0c9e7e594e130b63e"><td class="memItemLeft" align="right" valign="top"><a id="a3831a134c2f14ab0c9e7e594e130b63e"></a>
unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classot_1_1subDA.html#a3831a134c2f14ab0c9e7e594e130b63e">m_uiPreGhostNodeSize</a></td></tr>
<tr class="memdesc:a3831a134c2f14ab0c9e7e594e130b63e"><td class="mdescLeft">&#160;</td><td class="mdescRight">: pre ghost node size <br /></td></tr>
<tr class="separator:a3831a134c2f14ab0c9e7e594e130b63e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abf07e9854850539648a0991b1d450bac"><td class="memItemLeft" align="right" valign="top"><a id="abf07e9854850539648a0991b1d450bac"></a>
unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classot_1_1subDA.html#abf07e9854850539648a0991b1d450bac">m_uiPostGhostNodeSize</a></td></tr>
<tr class="memdesc:abf07e9854850539648a0991b1d450bac"><td class="mdescLeft">&#160;</td><td class="mdescRight">: post ghost node size <br /></td></tr>
<tr class="separator:abf07e9854850539648a0991b1d450bac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7b69433efd69f57894b25a129081d8c4"><td class="memItemLeft" align="right" valign="top"><a id="a7b69433efd69f57894b25a129081d8c4"></a>
unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classot_1_1subDA.html#a7b69433efd69f57894b25a129081d8c4">m_uiCommTag</a></td></tr>
<tr class="memdesc:a7b69433efd69f57894b25a129081d8c4"><td class="mdescLeft">&#160;</td><td class="mdescRight">: async comm tag <br /></td></tr>
<tr class="separator:a7b69433efd69f57894b25a129081d8c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9e0a6b0034c5e13ffc7354216e133d73"><td class="memItemLeft" align="right" valign="top"><a id="a9e0a6b0034c5e13ffc7354216e133d73"></a>
std::vector&lt; <a class="el" href="classot_1_1AsyncExchangeContex.html">AsyncExchangeContex</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>m_uiMPIContexts</b></td></tr>
<tr class="separator:a9e0a6b0034c5e13ffc7354216e133d73"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a448a819241fd6289d8833c71caadb7be"><td class="memItemLeft" align="right" valign="top"><a id="a448a819241fd6289d8833c71caadb7be"></a>
<a class="el" href="structot_1_1LoopCounter.html">LoopCounter</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classot_1_1subDA.html#a448a819241fd6289d8833c71caadb7be">m_uiLoopInfo</a></td></tr>
<tr class="memdesc:a448a819241fd6289d8833c71caadb7be"><td class="mdescLeft">&#160;</td><td class="mdescRight">: Loop counter info <br /></td></tr>
<tr class="separator:a448a819241fd6289d8833c71caadb7be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1f9ec2e2960368c45136b52facde59ff"><td class="memItemLeft" align="right" valign="top"><a id="a1f9ec2e2960368c45136b52facde59ff"></a>
std::vector&lt; <a class="el" href="classot_1_1AsyncExchangeContex.html">AsyncExchangeContex</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classot_1_1subDA.html#a1f9ec2e2960368c45136b52facde59ff">m_mpiContexts</a></td></tr>
<tr class="memdesc:a1f9ec2e2960368c45136b52facde59ff"><td class="mdescLeft">&#160;</td><td class="mdescRight">: async comm contex <br /></td></tr>
<tr class="separator:a1f9ec2e2960368c45136b52facde59ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af6dd096cf411b9ad02f33da89507f2f4"><td class="memItemLeft" align="right" valign="top"><a id="af6dd096cf411b9ad02f33da89507f2f4"></a>
std::vector&lt; unsigned int &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classot_1_1subDA.html#af6dd096cf411b9ad02f33da89507f2f4">m_uip_sub2DA_ElemMap</a></td></tr>
<tr class="memdesc:af6dd096cf411b9ad02f33da89507f2f4"><td class="mdescLeft">&#160;</td><td class="mdescRight">: <a class="el" href="classot_1_1subDA.html" title="subDA based on the DA, where to perform computations sub domain of the main domain. ">subDA</a> to <a class="el" href="classot_1_1DA.html">DA</a> map (elemental) <br /></td></tr>
<tr class="separator:af6dd096cf411b9ad02f33da89507f2f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5cbc84239bea577824b3b6a9890b3293"><td class="memItemLeft" align="right" valign="top"><a id="a5cbc84239bea577824b3b6a9890b3293"></a>
std::vector&lt; unsigned int &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classot_1_1subDA.html#a5cbc84239bea577824b3b6a9890b3293">m_uip_DA2sub_ElemMap</a></td></tr>
<tr class="memdesc:a5cbc84239bea577824b3b6a9890b3293"><td class="mdescLeft">&#160;</td><td class="mdescRight">: <a class="el" href="classot_1_1DA.html">DA</a> to <a class="el" href="classot_1_1subDA.html" title="subDA based on the DA, where to perform computations sub domain of the main domain. ">subDA</a> map (elemental) <br /></td></tr>
<tr class="separator:a5cbc84239bea577824b3b6a9890b3293"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af7d41de48a37513b9a0882ee5761e688"><td class="memItemLeft" align="right" valign="top"><a id="af7d41de48a37513b9a0882ee5761e688"></a>
std::vector&lt; unsigned int &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classot_1_1subDA.html#af7d41de48a37513b9a0882ee5761e688">m_uip_sub2DA_NodeMap</a></td></tr>
<tr class="memdesc:af7d41de48a37513b9a0882ee5761e688"><td class="mdescLeft">&#160;</td><td class="mdescRight">: <a class="el" href="classot_1_1subDA.html" title="subDA based on the DA, where to perform computations sub domain of the main domain. ">subDA</a> to <a class="el" href="classot_1_1DA.html">DA</a> map (nodal) <br /></td></tr>
<tr class="separator:af7d41de48a37513b9a0882ee5761e688"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3b380138b22790722cb45bfb985b6d93"><td class="memItemLeft" align="right" valign="top"><a id="a3b380138b22790722cb45bfb985b6d93"></a>
std::vector&lt; unsigned int &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classot_1_1subDA.html#a3b380138b22790722cb45bfb985b6d93">m_uip_DA2sub_NodeMap</a></td></tr>
<tr class="memdesc:a3b380138b22790722cb45bfb985b6d93"><td class="mdescLeft">&#160;</td><td class="mdescRight">: <a class="el" href="classot_1_1DA.html">DA</a> to <a class="el" href="classot_1_1subDA.html" title="subDA based on the DA, where to perform computations sub domain of the main domain. ">subDA</a> map (nodal) <br /></td></tr>
<tr class="separator:a3b380138b22790722cb45bfb985b6d93"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acdec623df205bbcb4fd14ab544a8f0a4"><td class="memItemLeft" align="right" valign="top"><a id="acdec623df205bbcb4fd14ab544a8f0a4"></a>
double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classot_1_1subDA.html#acdec623df205bbcb4fd14ab544a8f0a4">m_dMinBB</a> [3]</td></tr>
<tr class="memdesc:acdec623df205bbcb4fd14ab544a8f0a4"><td class="mdescLeft">&#160;</td><td class="mdescRight">min bound box for fe_retain <br /></td></tr>
<tr class="separator:acdec623df205bbcb4fd14ab544a8f0a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac94d4c6789196bc18b0305d8cff5e8a5"><td class="memItemLeft" align="right" valign="top"><a id="ac94d4c6789196bc18b0305d8cff5e8a5"></a>
double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classot_1_1subDA.html#ac94d4c6789196bc18b0305d8cff5e8a5">m_dMaxBB</a> [3]</td></tr>
<tr class="memdesc:ac94d4c6789196bc18b0305d8cff5e8a5"><td class="mdescLeft">&#160;</td><td class="mdescRight">max bound box for fe_retain <br /></td></tr>
<tr class="separator:ac94d4c6789196bc18b0305d8cff5e8a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aba563bb142b1a3f3db5fdd7413ae8aa1"><td class="memItemLeft" align="right" valign="top"><a id="aba563bb142b1a3f3db5fdd7413ae8aa1"></a>
unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classot_1_1subDA.html#aba563bb142b1a3f3db5fdd7413ae8aa1">m_uiTotalNodalSz</a></td></tr>
<tr class="memdesc:aba563bb142b1a3f3db5fdd7413ae8aa1"><td class="mdescLeft">&#160;</td><td class="mdescRight">total nodal size (zipped nodal size) <br /></td></tr>
<tr class="separator:aba563bb142b1a3f3db5fdd7413ae8aa1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5a5a341c99391679471d659aeaacab92"><td class="memItemLeft" align="right" valign="top"><a id="a5a5a341c99391679471d659aeaacab92"></a>
unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classot_1_1subDA.html#a5a5a341c99391679471d659aeaacab92">m_uiLocalNodalSz</a></td></tr>
<tr class="memdesc:a5a5a341c99391679471d659aeaacab92"><td class="mdescLeft">&#160;</td><td class="mdescRight">number of local nodes <br /></td></tr>
<tr class="separator:a5a5a341c99391679471d659aeaacab92"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaf484f309bf608863963517ba870c9cf"><td class="memItemLeft" align="right" valign="top"><a id="aaf484f309bf608863963517ba870c9cf"></a>
unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classot_1_1subDA.html#aaf484f309bf608863963517ba870c9cf">m_uiTotalElementSz</a></td></tr>
<tr class="memdesc:aaf484f309bf608863963517ba870c9cf"><td class="mdescLeft">&#160;</td><td class="mdescRight">total element size <br /></td></tr>
<tr class="separator:aaf484f309bf608863963517ba870c9cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3eeacfe6ce75d3de498729ee5f32d7dc"><td class="memItemLeft" align="right" valign="top"><a id="a3eeacfe6ce75d3de498729ee5f32d7dc"></a>
unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classot_1_1subDA.html#a3eeacfe6ce75d3de498729ee5f32d7dc">m_uiLocalElementSz</a></td></tr>
<tr class="memdesc:a3eeacfe6ce75d3de498729ee5f32d7dc"><td class="mdescLeft">&#160;</td><td class="mdescRight">local elemental size <br /></td></tr>
<tr class="separator:a3eeacfe6ce75d3de498729ee5f32d7dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae82693e8c81713ac85ccfda3064c798b"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classot_1_1subDA.html#ae82693e8c81713ac85ccfda3064c798b">m_uiElementPreGhostBegin</a> = 0</td></tr>
<tr class="separator:ae82693e8c81713ac85ccfda3064c798b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a60d88c73b6de41c39c14b3dc2161803d"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classot_1_1subDA.html#a60d88c73b6de41c39c14b3dc2161803d">m_uiElementPreGhostEnd</a></td></tr>
<tr class="separator:a60d88c73b6de41c39c14b3dc2161803d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3e49ffc6a2f2c913690d437e3ab67518"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classot_1_1subDA.html#a3e49ffc6a2f2c913690d437e3ab67518">m_uiElementLocalBegin</a></td></tr>
<tr class="separator:a3e49ffc6a2f2c913690d437e3ab67518"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1f304168ced9011eceb53d64a1b92ab8"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classot_1_1subDA.html#a1f304168ced9011eceb53d64a1b92ab8">m_uiElementLocalEnd</a></td></tr>
<tr class="separator:a1f304168ced9011eceb53d64a1b92ab8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab1afc0299e4ecd8ad07f553772f4a9d7"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classot_1_1subDA.html#ab1afc0299e4ecd8ad07f553772f4a9d7">m_uiElementPostGhostBegin</a></td></tr>
<tr class="separator:ab1afc0299e4ecd8ad07f553772f4a9d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af0244810e62304b6bc07b790ca23dd33"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classot_1_1subDA.html#af0244810e62304b6bc07b790ca23dd33">m_uiElementPostGhostEnd</a></td></tr>
<tr class="separator:af0244810e62304b6bc07b790ca23dd33"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adcbff66c3c7f6bdce4e2aed9ac94d81b"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classot_1_1subDA.html#adcbff66c3c7f6bdce4e2aed9ac94d81b">m_uiNodePreGhostBegin</a> =0</td></tr>
<tr class="separator:adcbff66c3c7f6bdce4e2aed9ac94d81b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ace3918784b5c4109db48daf586210243"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classot_1_1subDA.html#ace3918784b5c4109db48daf586210243">m_uiNodePreGhostEnd</a></td></tr>
<tr class="separator:ace3918784b5c4109db48daf586210243"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a33b6e4a3c62b87ff08bd95c2ba1d9a56"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classot_1_1subDA.html#a33b6e4a3c62b87ff08bd95c2ba1d9a56">m_uiNodeLocalBegin</a></td></tr>
<tr class="separator:a33b6e4a3c62b87ff08bd95c2ba1d9a56"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0c100859dc8331b36d7b149b21600ac6"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classot_1_1subDA.html#a0c100859dc8331b36d7b149b21600ac6">m_uiNodeLocalEnd</a></td></tr>
<tr class="separator:a0c100859dc8331b36d7b149b21600ac6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a26329a130e2ecbc534f09674ad4d6cbf"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classot_1_1subDA.html#a26329a130e2ecbc534f09674ad4d6cbf">m_uiNodePostGhostBegin</a></td></tr>
<tr class="separator:a26329a130e2ecbc534f09674ad4d6cbf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5b59a418572a98f541ca41d421bdfdc3"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classot_1_1subDA.html#a5b59a418572a98f541ca41d421bdfdc3">m_uiNodePostGhostEnd</a></td></tr>
<tr class="separator:a5b59a418572a98f541ca41d421bdfdc3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a954b6a7924eeb08489f7c25586dc4a05"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classot_1_1subDA.html#a954b6a7924eeb08489f7c25586dc4a05">m_uiNumPreGhostElements</a></td></tr>
<tr class="separator:a954b6a7924eeb08489f7c25586dc4a05"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6cd9210d25b3176c1ed2a5615a1d909d"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classot_1_1subDA.html#a6cd9210d25b3176c1ed2a5615a1d909d">m_uiNumLocalElements</a></td></tr>
<tr class="separator:a6cd9210d25b3176c1ed2a5615a1d909d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a501143873fd3b10f1c869a523bc9acda"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classot_1_1subDA.html#a501143873fd3b10f1c869a523bc9acda">m_uiNumPostGhostElements</a></td></tr>
<tr class="separator:a501143873fd3b10f1c869a523bc9acda"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a79f197e411de256896739422447182bc"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classot_1_1subDA.html#a79f197e411de256896739422447182bc">m_uiNumPreGhostNodes</a></td></tr>
<tr class="separator:a79f197e411de256896739422447182bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab1b75e1ddb7ae31352e71f4d37682b08"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classot_1_1subDA.html#ab1b75e1ddb7ae31352e71f4d37682b08">m_uiNumLocalNodes</a></td></tr>
<tr class="separator:ab1b75e1ddb7ae31352e71f4d37682b08"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5c331fcf7c89257a7e300f931bfe244a"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classot_1_1subDA.html#a5c331fcf7c89257a7e300f931bfe244a">m_uiNumPostGhostNodes</a></td></tr>
<tr class="separator:a5c331fcf7c89257a7e300f931bfe244a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab1fdd84cfb4ff68bbb78c56841dd0e3f"><td class="memItemLeft" align="right" valign="top"><a id="ab1fdd84cfb4ff68bbb78c56841dd0e3f"></a>
std::vector&lt; unsigned int &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classot_1_1subDA.html#ab1fdd84cfb4ff68bbb78c56841dd0e3f">m_uiSendScatterMap</a></td></tr>
<tr class="memdesc:ab1fdd84cfb4ff68bbb78c56841dd0e3f"><td class="mdescLeft">&#160;</td><td class="mdescRight">: Send scatter map <br /></td></tr>
<tr class="separator:ab1fdd84cfb4ff68bbb78c56841dd0e3f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4c956a06022812fc4e9751ce892cb374"><td class="memItemLeft" align="right" valign="top"><a id="a4c956a06022812fc4e9751ce892cb374"></a>
std::vector&lt; unsigned int &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classot_1_1subDA.html#a4c956a06022812fc4e9751ce892cb374">m_uiRecvScatterMap</a></td></tr>
<tr class="memdesc:a4c956a06022812fc4e9751ce892cb374"><td class="mdescLeft">&#160;</td><td class="mdescRight">: recv scatter map <br /></td></tr>
<tr class="separator:a4c956a06022812fc4e9751ce892cb374"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a911000b89a95ac92b1b93e9103130f78"><td class="memItemLeft" align="right" valign="top"><a id="a911000b89a95ac92b1b93e9103130f78"></a>
std::vector&lt; unsigned int &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classot_1_1subDA.html#a911000b89a95ac92b1b93e9103130f78">m_uiSendCounts</a></td></tr>
<tr class="memdesc:a911000b89a95ac92b1b93e9103130f78"><td class="mdescLeft">&#160;</td><td class="mdescRight">: send counts <br /></td></tr>
<tr class="separator:a911000b89a95ac92b1b93e9103130f78"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab94f68f8a9e34331a342743091a89fc9"><td class="memItemLeft" align="right" valign="top"><a id="ab94f68f8a9e34331a342743091a89fc9"></a>
std::vector&lt; unsigned int &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classot_1_1subDA.html#ab94f68f8a9e34331a342743091a89fc9">m_uiRecvCounts</a></td></tr>
<tr class="memdesc:ab94f68f8a9e34331a342743091a89fc9"><td class="mdescLeft">&#160;</td><td class="mdescRight">: recv counts <br /></td></tr>
<tr class="separator:ab94f68f8a9e34331a342743091a89fc9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad83686ef425128b12b52b85ee63161a1"><td class="memItemLeft" align="right" valign="top"><a id="ad83686ef425128b12b52b85ee63161a1"></a>
std::vector&lt; unsigned int &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classot_1_1subDA.html#ad83686ef425128b12b52b85ee63161a1">m_uiSendOffsets</a></td></tr>
<tr class="memdesc:ad83686ef425128b12b52b85ee63161a1"><td class="mdescLeft">&#160;</td><td class="mdescRight">: send offsets <br /></td></tr>
<tr class="separator:ad83686ef425128b12b52b85ee63161a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad9d34abf6be8aeb51c36a27e72648432"><td class="memItemLeft" align="right" valign="top"><a id="ad9d34abf6be8aeb51c36a27e72648432"></a>
std::vector&lt; unsigned int &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classot_1_1subDA.html#ad9d34abf6be8aeb51c36a27e72648432">m_uiRecvOffsets</a></td></tr>
<tr class="memdesc:ad9d34abf6be8aeb51c36a27e72648432"><td class="mdescLeft">&#160;</td><td class="mdescRight">: recv offsets <br /></td></tr>
<tr class="separator:ad9d34abf6be8aeb51c36a27e72648432"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a070c4d6eb036618f54444b7882c8f936"><td class="memItemLeft" align="right" valign="top">std::vector&lt; unsigned int &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classot_1_1subDA.html#a070c4d6eb036618f54444b7882c8f936">m_uiSendProcList</a></td></tr>
<tr class="separator:a070c4d6eb036618f54444b7882c8f936"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a13e2498b712c967c2c2795e921031f23"><td class="memItemLeft" align="right" valign="top">std::vector&lt; unsigned int &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classot_1_1subDA.html#a13e2498b712c967c2c2795e921031f23">m_uiRecvProcList</a></td></tr>
<tr class="separator:a13e2498b712c967c2c2795e921031f23"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af925f722f29ade3272fc11a844d2cd67"><td class="memItemLeft" align="right" valign="top"><a id="af925f722f29ade3272fc11a844d2cd67"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classot_1_1subDA.html#af925f722f29ade3272fc11a844d2cd67">m_uiIsActive</a></td></tr>
<tr class="memdesc:af925f722f29ade3272fc11a844d2cd67"><td class="mdescLeft">&#160;</td><td class="mdescRight">: active sub da <br /></td></tr>
<tr class="separator:af925f722f29ade3272fc11a844d2cd67"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aba25437891330799d97ebd182e27ec02"><td class="memItemLeft" align="right" valign="top"><a id="aba25437891330799d97ebd182e27ec02"></a>
MPI_Comm&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classot_1_1subDA.html#aba25437891330799d97ebd182e27ec02">m_uiCommGlobal</a></td></tr>
<tr class="memdesc:aba25437891330799d97ebd182e27ec02"><td class="mdescLeft">&#160;</td><td class="mdescRight">: MPI comm global <br /></td></tr>
<tr class="separator:aba25437891330799d97ebd182e27ec02"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2d7668ac26f7587c26d23c26330192c0"><td class="memItemLeft" align="right" valign="top"><a id="a2d7668ac26f7587c26d23c26330192c0"></a>
MPI_Comm&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classot_1_1subDA.html#a2d7668ac26f7587c26d23c26330192c0">m_uiCommActive</a></td></tr>
<tr class="memdesc:a2d7668ac26f7587c26d23c26330192c0"><td class="mdescLeft">&#160;</td><td class="mdescRight">: MPI_Comm for the active <br /></td></tr>
<tr class="separator:a2d7668ac26f7587c26d23c26330192c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aebf77d390239106b36ba4b4194733e87"><td class="memItemLeft" align="right" valign="top"><a id="aebf77d390239106b36ba4b4194733e87"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classot_1_1subDA.html#aebf77d390239106b36ba4b4194733e87">m_uiRankActive</a></td></tr>
<tr class="memdesc:aebf77d390239106b36ba4b4194733e87"><td class="mdescLeft">&#160;</td><td class="mdescRight">: rank active <br /></td></tr>
<tr class="separator:aebf77d390239106b36ba4b4194733e87"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af3a3ab21d927d318642da1cd847adb05"><td class="memItemLeft" align="right" valign="top"><a id="af3a3ab21d927d318642da1cd847adb05"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classot_1_1subDA.html#af3a3ab21d927d318642da1cd847adb05">m_uiRankGlobal</a></td></tr>
<tr class="memdesc:af3a3ab21d927d318642da1cd847adb05"><td class="mdescLeft">&#160;</td><td class="mdescRight">: rank global <br /></td></tr>
<tr class="separator:af3a3ab21d927d318642da1cd847adb05"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adc2bbd022f053134956fa9c5438af1ed"><td class="memItemLeft" align="right" valign="top"><a id="adc2bbd022f053134956fa9c5438af1ed"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classot_1_1subDA.html#adc2bbd022f053134956fa9c5438af1ed">m_uiNpesActive</a></td></tr>
<tr class="memdesc:adc2bbd022f053134956fa9c5438af1ed"><td class="mdescLeft">&#160;</td><td class="mdescRight">: npes active <br /></td></tr>
<tr class="separator:adc2bbd022f053134956fa9c5438af1ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a92118d33c41bf199cac225f4a92b8349"><td class="memItemLeft" align="right" valign="top"><a id="a92118d33c41bf199cac225f4a92b8349"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classot_1_1subDA.html#a92118d33c41bf199cac225f4a92b8349">m_uiNpesGlobal</a></td></tr>
<tr class="memdesc:a92118d33c41bf199cac225f4a92b8349"><td class="mdescLeft">&#160;</td><td class="mdescRight">: npes global <br /></td></tr>
<tr class="separator:a92118d33c41bf199cac225f4a92b8349"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p><a class="el" href="classot_1_1subDA.html" title="subDA based on the DA, where to perform computations sub domain of the main domain. ">subDA</a> based on the <a class="el" href="classot_1_1DA.html">DA</a>, where to perform computations sub domain of the main domain. </p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a35e0ce21db9c82b0be5f8ec6abacc2bf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a35e0ce21db9c82b0be5f8ec6abacc2bf">&#9670;&nbsp;</a></span>subDA()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ot::subDA::subDA </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classot_1_1DA.html">ot::DA</a> *&#160;</td>
          <td class="paramname"><em>da</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::function&lt; double(double, double, double) &gt;&#160;</td>
          <td class="paramname"><em>fx_retain</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>gSize</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>: defult sub da constructor. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">da</td><td>input <a class="el" href="classot_1_1DA.html">DA</a> </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">fx_retain</td><td>: area to retain param[in] gSize: global domain size. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a00ae80d9f8417fe20081fc662d95a6fb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a00ae80d9f8417fe20081fc662d95a6fb">&#9670;&nbsp;</a></span>copyVector()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void ot::subDA::copyVector </td>
          <td>(</td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T *&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>isElemental</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>isGhosted</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>more premitive copy, from source pointer to the dest pointer </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">[in/out]</td><td>dest: destination pointer </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">source</td><td>source pointer </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">isElemental</td><td>true if this is an elemental vector/ false otherwise </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">isGhosted</td><td>true if this is a ghosted vector </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a4da2962a4fa74a47dd6f24ba5c597ca4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4da2962a4fa74a47dd6f24ba5c597ca4">&#9670;&nbsp;</a></span>copyVectors()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void ot::subDA::copyVectors </td>
          <td>(</td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T *&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>isElemental</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>isGhosted</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>dof</em> = <code>1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>copy vecotor to sorce to destination, assumes the same number of dof. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">[in/out]</td><td>dest: destination pointer </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">source</td><td>source pointer </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">isElemental</td><td>true if this is an elemental vector/ false otherwise </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">isGhosted</td><td>true if this is a ghosted vector </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">dof</td><td>degrees of freedoms </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a56aa20897ab340a6e5c69cee310a1a7e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a56aa20897ab340a6e5c69cee310a1a7e">&#9670;&nbsp;</a></span>createVector() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">int ot::subDA::createVector </td>
          <td>(</td>
          <td class="paramtype">T *&amp;&#160;</td>
          <td class="paramname"><em>local</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>isElemental</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>isGhosted</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>dof</em> = <code>1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a ODA vector. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">local</td><td>: VecType pointer </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">isElemental</td><td>True if creating a elemental vector (cell data vector) false for a nodal vector </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">isGhosted</td><td>True will allocate ghost nodal values as well, false will only allocate memory for local nodes. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">dof</td><td>degrees of freedoms </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a384bbf133a56f573658be57fe143d227"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a384bbf133a56f573658be57fe143d227">&#9670;&nbsp;</a></span>createVector() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">int ot::subDA::createVector </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>local</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>isElemental</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>isGhosted</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>dof</em> = <code>1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a ODA vector std::vector&lt;T&gt; </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">local</td><td>: VecType pointer </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">isElemental</td><td>True if creating a elemental vector (cell data vector) false for a nodal vector </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">isGhosted</td><td>True will allocate ghost nodal values as well, false will only allocate memory for local nodes. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">dof</td><td>degrees of freedoms </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aafe5e5697dbc68c719dc59059cf61bca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aafe5e5697dbc68c719dc59059cf61bca">&#9670;&nbsp;</a></span>destroyVector()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void ot::subDA::destroyVector </td>
          <td>(</td>
          <td class="paramtype">T *&amp;&#160;</td>
          <td class="paramname"><em>local</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>deallocates the memory allocated for a vector </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname"></td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af729167f9e7a72b5a2a8e98ef66cd7ad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af729167f9e7a72b5a2a8e98ef66cd7ad">&#9670;&nbsp;</a></span>eleVecToVecAccumilation()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void ot::subDA::eleVecToVecAccumilation </td>
          <td>(</td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T *&#160;</td>
          <td class="paramname"><em>eleVecIn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>eleID</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>dof</em> = <code>1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>computes the elemental vec to global vec accumilation </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">out</td><td>output (need to be ghosted ) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">eleVecIn</td><td>eleVec values. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">eleID</td><td>element ID </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">dof</td><td>degrees of freedoms </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a26606bbf5242666eb2b757eeff900453"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a26606bbf5242666eb2b757eeff900453">&#9670;&nbsp;</a></span>getElementalCoords()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ot::subDA::getElementalCoords </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>eleID</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>coords</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>computes the elementCoordinates (based on the nodal placement) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">eleID</td><td>: element ID </td></tr>
    <tr><td class="paramdir"></td><td class="paramname"></td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae642a22eea82cfa329b6d16507526c50"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae642a22eea82cfa329b6d16507526c50">&#9670;&nbsp;</a></span>getElementNodalValues()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void ot::subDA::getElementNodalValues </td>
          <td>(</td>
          <td class="paramtype">const T *&#160;</td>
          <td class="paramname"><em>in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>eleVecOut</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>eleID</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>dof</em> = <code>1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>computes the element nodal values using interpolation if needed. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">in</td><td>input vector (need to be ghosted ) </td></tr>
    <tr><td class="paramdir"></td><td class="paramname"></td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a737ee05a2cabc91ea17e39838c19171f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a737ee05a2cabc91ea17e39838c19171f">&#9670;&nbsp;</a></span>getFaceNeighborValues()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">int ot::subDA::getFaceNeighborValues </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>eleID</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T *&#160;</td>
          <td class="paramname"><em>in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>coords</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int *&#160;</td>
          <td class="paramname"><em>neighID</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>face</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">NeighbourLevel &amp;&#160;</td>
          <td class="paramname"><em>level</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>computes the face neighbor points for additional computations for a specified direction. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">eleID</td><td>element ID </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">in</td><td>inpute vector </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">out</td><td>output vector values are in the order of the x,y,z size : 4*NodesPerElement </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">coords</td><td>get the corresponding coordinates size: 4*NodesPerElement*m_uiDim; </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">neighID</td><td>face neighbor octant IDs, </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">face</td><td>face direction in {OCT_DIR_LEFT,OCT_IDR_RIGHT,OCT_DIR_DOWN, OCT_DIR_UP,OCT_DIR_BACK,OCT_DIR_FRONT} </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">level</td><td>the level of the neighbour octant with respect to the current octant. returns the number of face neighbours 1/4 for 3D. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a93dfe2b167170822f416426e262ab831"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a93dfe2b167170822f416426e262ab831">&#9670;&nbsp;</a></span>getGlobalNodeIndices()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int ot::subDA::getGlobalNodeIndices </td>
          <td>(</td>
          <td class="paramtype">DendroIntL *&#160;</td>
          <td class="paramname"><em>nodeIdx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>ele</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the global node indices of a given element,. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">nodeIdx</td><td>global node indices, </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ele</td><td>element id </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a59e0f22aca4f07d8e15a8ed70c761f98"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a59e0f22aca4f07d8e15a8ed70c761f98">&#9670;&nbsp;</a></span>getLevel()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int ot::subDA::getLevel </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>ele</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>return the level of current octant </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ele</td><td>elementID of the current octant </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a8725e794a81b1c00ab69e65229053e7e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8725e794a81b1c00ab69e65229053e7e">&#9670;&nbsp;</a></span>getMesh()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classot_1_1Mesh.html">ot::Mesh</a>* ot::subDA::getMesh </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>: returns node local to node global map </p>
<p>returns the mesh </p>

</div>
</div>
<a id="aeae4eeb0c9533278c2e63ab918c53080"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeae4eeb0c9533278c2e63ab918c53080">&#9670;&nbsp;</a></span>getNodeIndices()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int ot::subDA::getNodeIndices </td>
          <td>(</td>
          <td class="paramtype">DendroIntL *&#160;</td>
          <td class="paramname"><em>nodeIdx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>ele</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>isGhosted</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the local indices to the nodes of the current element. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">nodes</td><td>Indices into the nodes of the given element. Should be allocated by the user prior to calling. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>-1 for error </dd></dl>

</div>
</div>
<a id="a9e3c3c96ee5c35c47e153c2e71088356"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9e3c3c96ee5c35c47e153c2e71088356">&#9670;&nbsp;</a></span>getOctant()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classot_1_1TreeNode.html">ot::TreeNode</a> ot::subDA::getOctant </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>ele</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>return the <a class="el" href="classot_1_1TreeNode.html" title="A class to manage octants. ">TreeNode</a> of the current octnat. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ele</td><td>elementID of the current octant </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a42ace0325fd34c16c2502608808d39c2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a42ace0325fd34c16c2502608808d39c2">&#9670;&nbsp;</a></span>getOctreeBoundaryNodeIndices()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ot::subDA::getOctreeBoundaryNodeIndices </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; unsigned int &gt; &amp;&#160;</td>
          <td class="paramname"><em>bdyIndex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>coords</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>isGhosted</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes the octree writable boundary nodes. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname"></td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a4cbff6412365bc65a213a86dc937f711"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4cbff6412365bc65a213a86dc937f711">&#9670;&nbsp;</a></span>getVecPointerToDof()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">T* ot::subDA::getVecPointerToDof </td>
          <td>(</td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>dofInex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>isElemental</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>isGhosted</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>returns a pointer to a dof index, </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">in</td><td>input vector pointer </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">dofInex</td><td>dof index which is the pointer is needed, should be less than dof, value the vector created. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">isElemental</td><td>true if this is an elemental vector/ false otherwise </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">isGhosted</td><td>true if this is a ghosted vector </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>pointer to dofIndex. </dd></dl>

</div>
</div>
<a id="a2aed4e5133cf948a466c649317260269"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2aed4e5133cf948a466c649317260269">&#9670;&nbsp;</a></span>ghostedNodalToNodalVec()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void ot::subDA::ghostedNodalToNodalVec </td>
          <td>(</td>
          <td class="paramtype">const T *&#160;</td>
          <td class="paramname"><em>gVec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T *&amp;&#160;</td>
          <td class="paramname"><em>local</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>isAllocated</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>dof</em> = <code>1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>convert ghosted nodal vector to local vector (without ghosting) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">gVec</td><td>ghosted vector </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">local</td><td>local vector (assume an allocated vector) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">isAllocated</td><td>true if the out is allocated, false otherwise. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">dof</td><td>degrees of freedoms </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac9931b07b79a9f43f19e1c06876de338"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac9931b07b79a9f43f19e1c06876de338">&#9670;&nbsp;</a></span>intergridTransfer()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void ot::subDA::intergridTransfer </td>
          <td>(</td>
          <td class="paramtype">const T *&#160;</td>
          <td class="paramname"><em>varIn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T *&amp;&#160;</td>
          <td class="paramname"><em>varOut</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classot_1_1DA.html">ot::DA</a> *&#160;</td>
          <td class="paramname"><em>newDA</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>isElemental</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>isGhosted</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>dof</em> = <code>1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>performs grid transfer operations after the remesh. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">varIn</td><td>variable defined by oldDA </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">varOut</td><td>variable defined by newDA. interpolate varOut from varIn. (Note: varOut allocated inside the function, no need to allocate outside) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">isElemental</td><td>true if it is an elemental vector </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">isGhosted</td><td>true if allocated ghost vector </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">dof</td><td>degrees of freedoms. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab638f20c1163045b6c5c74bcfa912bd4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab638f20c1163045b6c5c74bcfa912bd4">&#9670;&nbsp;</a></span>isBoundaryOctant()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ot::subDA::isBoundaryOctant </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>eleID</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>: returns true if specified eleID is a boundary element false if the eleID is local and not a boundary element. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">eleID</td><td>element ID </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac7d0fa5f47a217afbbbc2638ffef7c55"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac7d0fa5f47a217afbbbc2638ffef7c55">&#9670;&nbsp;</a></span>nodalVecToGhostedNodal()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void ot::subDA::nodalVecToGhostedNodal </td>
          <td>(</td>
          <td class="paramtype">const T *&#160;</td>
          <td class="paramname"><em>in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T *&amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>isAllocated</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>dof</em> = <code>1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>convert nodal local vector with ghosted buffer regions. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">in</td><td>input vector (should be nodal and non ghosted) </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">out</td><td>coverted nodal vector with ghost regions. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">isAllocated</td><td>true if the out is allocated, false otherwise. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">dof</td><td>degrees of freedoms </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a2095453f1150e81cbe4484b082cd4068"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2095453f1150e81cbe4484b082cd4068">&#9670;&nbsp;</a></span>remesh()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classot_1_1DA.html">ot::DA</a>* ot::subDA::remesh </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="oda_8h.html#ac96bf616827a93d8d04265c95a356f09">DA_FLAGS::Refine</a> *&#160;</td>
          <td class="paramname"><em>flags</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>sz</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>grainSz</em> = <code>100</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>ld_bal</em> = <code>0.3</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>sfK</em> = <code>2</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>: Performs remesh based on the DA_FLAGS::Refine, which specifies no change, refine or coarsen. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">flags</td><td>refinement flags. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">sz</td><td>size of the array flags (needs to be size of the local elements) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">grainSz</td><td>rougly the number of octants per core you need when you create the new da. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ld_tol</td><td>load imbalance tolerance. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">sfK</td><td>splitter fix factor. better to be power of two. increase the value to 128 when running on &gt; 64,000 cores </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>: Specifies the new grid, with new <a class="el" href="classot_1_1DA.html">DA</a>. </dd></dl>

</div>
</div>
<a id="a80d19e2233cb7b7f518a8e0fa74060bf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a80d19e2233cb7b7f518a8e0fa74060bf">&#9670;&nbsp;</a></span>setVectorByFunction()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void ot::subDA::setVectorByFunction </td>
          <td>(</td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>local</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::function&lt; void(T, T, T, T *)&gt;&#160;</td>
          <td class="paramname"><em>func</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>isElemental</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>isGhosted</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>dof</em> = <code>1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>initialize a variable vector to a function depends on spatial coords. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname"></td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a911d5a75150ee552090a4c6e43ee9947"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a911d5a75150ee552090a4c6e43ee9947">&#9670;&nbsp;</a></span>setVectorByScalar()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void ot::subDA::setVectorByScalar </td>
          <td>(</td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>local</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T *&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>isElemental</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>isGhosted</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>dof</em> = <code>1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>initialize a variable vector to a function depends on spatial coords. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname"></td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a809466e1f727e08c7b79c73d4be90930"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a809466e1f727e08c7b79c73d4be90930">&#9670;&nbsp;</a></span>vecTopvtu()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void ot::subDA::vecTopvtu </td>
          <td>(</td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>local</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>fPrefix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char **&#160;</td>
          <td class="paramname"><em>nodalVarNames</em> = <code>NULL</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>isElemental</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>isGhosted</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>dof</em> = <code>1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>write the vec to pvtu file </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">local</td><td>variable vector </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">fPrefix</td><td>file name prefix </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">isElemental</td><td>True if creating a elemental vector (cell data vector) false for a nodal vector </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">isGhosted</td><td>True will allocate ghost nodal values as well, false will only allocate memory for local nodes. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">dof</td><td>degrees of freedoms </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="a3e49ffc6a2f2c913690d437e3ab67518"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3e49ffc6a2f2c913690d437e3ab67518">&#9670;&nbsp;</a></span>m_uiElementLocalBegin</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int ot::subDA::m_uiElementLocalBegin</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>begin of locat octants (INDEPENDENT) </p>

</div>
</div>
<a id="a1f304168ced9011eceb53d64a1b92ab8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1f304168ced9011eceb53d64a1b92ab8">&#9670;&nbsp;</a></span>m_uiElementLocalEnd</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int ot::subDA::m_uiElementLocalEnd</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>end of the local octants (INDEPENDET) </p>

</div>
</div>
<a id="ab1afc0299e4ecd8ad07f553772f4a9d7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab1afc0299e4ecd8ad07f553772f4a9d7">&#9670;&nbsp;</a></span>m_uiElementPostGhostBegin</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int ot::subDA::m_uiElementPostGhostBegin</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>begin location for the post ghost octants </p>

</div>
</div>
<a id="af0244810e62304b6bc07b790ca23dd33"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af0244810e62304b6bc07b790ca23dd33">&#9670;&nbsp;</a></span>m_uiElementPostGhostEnd</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int ot::subDA::m_uiElementPostGhostEnd</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>end location for the post ghost octants </p>

</div>
</div>
<a id="ae82693e8c81713ac85ccfda3064c798b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae82693e8c81713ac85ccfda3064c798b">&#9670;&nbsp;</a></span>m_uiElementPreGhostBegin</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int ot::subDA::m_uiElementPreGhostBegin = 0</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>begin of the pre ghost elements </p>

</div>
</div>
<a id="a60d88c73b6de41c39c14b3dc2161803d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a60d88c73b6de41c39c14b3dc2161803d">&#9670;&nbsp;</a></span>m_uiElementPreGhostEnd</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int ot::subDA::m_uiElementPreGhostEnd</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>end of pre ghost elements </p>

</div>
</div>
<a id="a33b6e4a3c62b87ff08bd95c2ba1d9a56"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a33b6e4a3c62b87ff08bd95c2ba1d9a56">&#9670;&nbsp;</a></span>m_uiNodeLocalBegin</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int ot::subDA::m_uiNodeLocalBegin</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>begin location of the local nodes in CG indexing </p>

</div>
</div>
<a id="a0c100859dc8331b36d7b149b21600ac6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0c100859dc8331b36d7b149b21600ac6">&#9670;&nbsp;</a></span>m_uiNodeLocalEnd</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int ot::subDA::m_uiNodeLocalEnd</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>end location of the local nodes in CG indexing </p>

</div>
</div>
<a id="a26329a130e2ecbc534f09674ad4d6cbf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a26329a130e2ecbc534f09674ad4d6cbf">&#9670;&nbsp;</a></span>m_uiNodePostGhostBegin</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int ot::subDA::m_uiNodePostGhostBegin</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>begin location of the post ghost nodes in CG indexing </p>

</div>
</div>
<a id="a5b59a418572a98f541ca41d421bdfdc3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5b59a418572a98f541ca41d421bdfdc3">&#9670;&nbsp;</a></span>m_uiNodePostGhostEnd</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int ot::subDA::m_uiNodePostGhostEnd</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>end location of the post ghost nodes in CG indexing </p>

</div>
</div>
<a id="adcbff66c3c7f6bdce4e2aed9ac94d81b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adcbff66c3c7f6bdce4e2aed9ac94d81b">&#9670;&nbsp;</a></span>m_uiNodePreGhostBegin</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int ot::subDA::m_uiNodePreGhostBegin =0</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>begin location of the pre ghost nodes in CG indexing </p>

</div>
</div>
<a id="ace3918784b5c4109db48daf586210243"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ace3918784b5c4109db48daf586210243">&#9670;&nbsp;</a></span>m_uiNodePreGhostEnd</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int ot::subDA::m_uiNodePreGhostEnd</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>end location of the pre ghost nodes in CG indexing </p>

</div>
</div>
<a id="a6cd9210d25b3176c1ed2a5615a1d909d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6cd9210d25b3176c1ed2a5615a1d909d">&#9670;&nbsp;</a></span>m_uiNumLocalElements</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int ot::subDA::m_uiNumLocalElements</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>number of local elements </p>

</div>
</div>
<a id="ab1b75e1ddb7ae31352e71f4d37682b08"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab1b75e1ddb7ae31352e71f4d37682b08">&#9670;&nbsp;</a></span>m_uiNumLocalNodes</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int ot::subDA::m_uiNumLocalNodes</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>number of local nodes </p>

</div>
</div>
<a id="a501143873fd3b10f1c869a523bc9acda"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a501143873fd3b10f1c869a523bc9acda">&#9670;&nbsp;</a></span>m_uiNumPostGhostElements</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int ot::subDA::m_uiNumPostGhostElements</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>number of post ghost elements </p>

</div>
</div>
<a id="a5c331fcf7c89257a7e300f931bfe244a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5c331fcf7c89257a7e300f931bfe244a">&#9670;&nbsp;</a></span>m_uiNumPostGhostNodes</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int ot::subDA::m_uiNumPostGhostNodes</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>number of post nodes </p>

</div>
</div>
<a id="a954b6a7924eeb08489f7c25586dc4a05"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a954b6a7924eeb08489f7c25586dc4a05">&#9670;&nbsp;</a></span>m_uiNumPreGhostElements</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int ot::subDA::m_uiNumPreGhostElements</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>number of pre ghost elements </p>

</div>
</div>
<a id="a79f197e411de256896739422447182bc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a79f197e411de256896739422447182bc">&#9670;&nbsp;</a></span>m_uiNumPreGhostNodes</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int ot::subDA::m_uiNumPreGhostNodes</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>number of pre ghost nodes </p>

</div>
</div>
<a id="a13e2498b712c967c2c2795e921031f23"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a13e2498b712c967c2c2795e921031f23">&#9670;&nbsp;</a></span>m_uiRecvProcList</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;unsigned int&gt; ot::subDA::m_uiRecvProcList</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>recv processor list for the ghost exchange </p>

</div>
</div>
<a id="a070c4d6eb036618f54444b7882c8f936"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a070c4d6eb036618f54444b7882c8f936">&#9670;&nbsp;</a></span>m_uiSendProcList</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;unsigned int&gt; ot::subDA::m_uiSendProcList</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Send processor list for ghost exchange </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>include/<a class="el" href="sub__oda_8h_source.html">sub_oda.h</a></li>
<li>src/sub_oda.cpp</li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
